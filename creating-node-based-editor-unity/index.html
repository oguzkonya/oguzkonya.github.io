<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Creating a Node Based Editor in Unity | oguzkonya</title>
<link rel="stylesheet" href="/assets/main.css">
<link rel="stylesheet" href="/assets/prism.css">
<link rel="alternate" type="application/rss+xml" title="oguzkonya" href="/feed.xml">
<script src="/assets/js/prism.js"></script>
<title>Creating a Node Based Editor in Unity | oguzkonya</title>
<meta name="generator" content="Jekyll v3.7.4" />
<meta property="og:title" content="Creating a Node Based Editor in Unity" />
<meta name="author" content="Oguz Konya" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Node based editors are frequently used in game engines; Unity has Animator window, Unreal Engine has blueprint system, some other game engines have dialogue systems. In this blog post, we will create our own node based editor in Unity. It’s going to be simple node editor that you’ll be able to improve upon later (see the below image for an example). I am going to assume that you are already familiar with editor scripting, but if you are not, please take your time to have a look at this post and this post." />
<meta property="og:description" content="Node based editors are frequently used in game engines; Unity has Animator window, Unreal Engine has blueprint system, some other game engines have dialogue systems. In this blog post, we will create our own node based editor in Unity. It’s going to be simple node editor that you’ll be able to improve upon later (see the below image for an example). I am going to assume that you are already familiar with editor scripting, but if you are not, please take your time to have a look at this post and this post." />
<link rel="canonical" href="http://localhost:4000/creating-node-based-editor-unity/" />
<meta property="og:url" content="http://localhost:4000/creating-node-based-editor-unity/" />
<meta property="og:site_name" content="oguzkonya" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-08-15T00:00:00+00:00" />
<script type="application/ld+json">
{"headline":"Creating a Node Based Editor in Unity","dateModified":"2019-08-15T00:00:00+00:00","datePublished":"2019-08-15T00:00:00+00:00","url":"http://localhost:4000/creating-node-based-editor-unity/","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/creating-node-based-editor-unity/"},"author":{"@type":"Person","name":"Oguz Konya"},"description":"Node based editors are frequently used in game engines; Unity has Animator window, Unreal Engine has blueprint system, some other game engines have dialogue systems. In this blog post, we will create our own node based editor in Unity. It’s going to be simple node editor that you’ll be able to improve upon later (see the below image for an example). I am going to assume that you are already familiar with editor scripting, but if you are not, please take your time to have a look at this post and this post.","@type":"BlogPosting","@context":"https://schema.org"}</script>
</head>
<body data-instant-allow-query-string data-instant-allow-external-links>
<header class="site-header">
 <div class="wrapper-header">
   <div class="header-left">
      <a class="site-title" href="/">oguzkonya</a>
   </div>
   <div class="header-right">
        <a class="page-link" href="/">all&nbsp;posts</a>
        <a class="page-link" href="/categories/">categories</a>
        <a class="page-link" href="/about/">about</a>
   </div>
 </div>
</header>
 <main class="page-content" aria-label="Content">
   <div class="wrapper-content">
     <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
<header class="post-header">
   <h1 class="post-title" itemprop="name headline">Creating a Node Based Editor in Unity</h1>
   <p class="post-meta">
      <time datetime="2019-08-15T00:00:00+00:00" itemprop="datePublished">
        Aug 15, 2019
      </time>
      •
      [
<a href="/category/unity/" rel="category">unity</a>,
<a href="/category/unity-editor/" rel="category">unity-editor</a>
]
      •
      <a href="#disqus_thread" data-disqus-identifier="">0 comments</a>
   </p>
 </header>
 <div class="post-content" itemprop="articleBody">
   <p>Node based editors are frequently used in game engines; Unity has Animator window, Unreal Engine has blueprint system, some other game engines have dialogue systems. In this blog post, we will create our own node based editor in Unity. It’s going to be simple node editor that you’ll be able to improve upon later (see the below image for an example). I am going to assume that you are already familiar with editor scripting, but if you are not, please take your time to have a look at <a href="/creating-editor-windows-in-unity/">this</a> post and <a href="/creating-clone-unitys-console-window/">this</a> post.</p>
<div class="img-wrapper">
    <a target="_blank" rel="noopener noreferrer" href="/assets/img/node-based-editor.gif">
        <img src="/assets/img/node-based-editor.gif" class="center" alt="Window" width="300px" />
    </a>
    <em>We will be creating this window in this post (click to see the gif in action)</em>
</div>
<h3 id="creating-the-window">Creating the Window</h3>
<p>Let’s start by creating a simple editor window. The structure of the code will be similar to that of the console clone we developed in the previous posts: draw the elements first, and then process input, and if the GUI is changed due to input events, force the window to repaint.</p><pre class=" language-csharp  line-numbers "><code>using UnityEngine;
using UnityEditor;
using System.Collections.Generic;

public class NodeBasedEditor : EditorWindow
{
    [MenuItem(&quot;Window/Node Based Editor&quot;)]
    private static void OpenWindow()
    {
        NodeBasedEditor window = GetWindow&lt;NodeBasedEditor&gt;();
        window.titleContent = new GUIContent(&quot;Node Based Editor&quot;);
    }

    private void OnGUI()
    {
        DrawNodes();

        ProcessEvents(Event.current);

        if (GUI.changed) Repaint();
    }

    private void DrawNodes()
    {
    }

    private void ProcessEvents(Event e)
    {
    }
}</code></pre>
<h3 id="drawing-nodes">Drawing Nodes</h3>
<p>Well, since this is a node editor, it should contain a list of nodes, which requires us to define a List<Node>. But first we should define __Node__ class. A __Node__ will be responsible for drawing itself and processing its own events. Unlike __ProcessEvents(Event e)__ in __NodeBasedEditor__, __ProcessEvents(Event e)__ in __Node__ will return a boolean so that we can check whether we should repaint the GUI or not.</Node></p><pre class=" language-csharp  line-numbers "><code>using System;
using UnityEditor;
using UnityEngine;

public class Node
{
    public Rect rect;
    public string title;

    public GUIStyle style;

    public Node(Vector2 position, float width, float height, GUIStyle nodeStyle)
    {
        rect = new Rect(position.x, position.y, width, height);
        style = nodeStyle;
    }

    public void Drag(Vector2 delta)
    {
        rect.position += delta;
    }

    public void Draw()
    {
        GUI.Box(rect, title, style);
    }

    public bool ProcessEvents(Event e)
    {
        return false;
    }
}</code></pre><pre class=" language-csharp  line-numbers "><code>using UnityEngine;
using UnityEditor;
using System.Collections.Generic;

public class NodeBasedEditor : EditorWindow
{
    private List&lt;Node&gt; nodes;

    [MenuItem(&quot;Window/Node Based Editor&quot;)]
    private static void OpenWindow()
    {
        NodeBasedEditor window = GetWindow&lt;NodeBasedEditor&gt;();
        window.titleContent = new GUIContent(&quot;Node Based Editor&quot;);
    }

    private void OnGUI()
    {
        DrawNodes();

        ProcessEvents(Event.current);

        if (GUI.changed) Repaint();
    }

    private void DrawNodes()
    {
        if (nodes != null)
        {
            for (int i = 0; i &lt; nodes.Count; i++)
            {
                nodes[i].Draw();
            }
        }
    }

    private void ProcessEvents(Event e)
    {
    }
}</code></pre>
<h3 id="creating-nodes">Creating Nodes</h3>
<p>Nodes are drawn in the editor now, but we can’t see them if we don’t create them. We should display a context menu with an “Add node” item when the user right clicks in the editor. When the user clicks “Add node”, we will create a <strong>Node</strong> and add it to the list of nodes, so that it is drawn. A <strong>Node</strong> requires a position, a width, a height and a styling; position will be the mouse’s current position, width will be 200, height will be 50 (yes, I don’t like using magic numbers in code, but this is going to be a simple editor, so the size doesn’t matter for the moment) and we will replicate the Animator window’s node style for styling.</p><pre class=" language-csharp  line-numbers "><code>using UnityEngine;
using UnityEditor;
using System.Collections.Generic;

public class NodeBasedEditor : EditorWindow
{
    private List&lt;Node&gt; nodes;

    private GUIStyle nodeStyle;

    [MenuItem(&quot;Window/Node Based Editor&quot;)]
    private static void OpenWindow()
    {
        NodeBasedEditor window = GetWindow&lt;NodeBasedEditor&gt;();
        window.titleContent = new GUIContent(&quot;Node Based Editor&quot;);
    }

    private void OnEnable()
    {
        nodeStyle = new GUIStyle();
        nodeStyle.normal.background = EditorGUIUtility.Load(&quot;builtin skins/darkskin/images/node1.png&quot;) as Texture2D;
        nodeStyle.border = new RectOffset(12, 12, 12, 12);
    }

    private void OnGUI()
    {
        DrawNodes();

        ProcessEvents(Event.current);

        if (GUI.changed) Repaint();
    }

    private void DrawNodes()
    {
        if (nodes != null)
        {
            for (int i = 0; i &lt; nodes.Count; i++)
            {
                nodes[i].Draw();
            }
        }
    }

    private void ProcessEvents(Event e)
    {
        switch (e.type)
        {
            case EventType.MouseDown:
                if (e.button == 1)
                {
                    ProcessContextMenu(e.mousePosition);
                }
                break;
        }
    }

    private void ProcessContextMenu(Vector2 mousePosition)
    {
        GenericMenu genericMenu = new GenericMenu();
        genericMenu.AddItem(new GUIContent(&quot;Add node&quot;), false, () =&gt; OnClickAddNode(mousePosition)); 
        genericMenu.ShowAsContext();
    }

    private void OnClickAddNode(Vector2 mousePosition)
    {
        if (nodes == null)
        {
            nodes = new List&lt;Node&gt;();
        }

        nodes.Add(new Node(mousePosition, 200, 50, nodeStyle));
    }
}</code></pre>
<h3 id="making-nodes-draggable">Making Nodes Draggable</h3>
<p>Alright, now we are able to add nodes, but we can’t drag them around. As I mentioned earlier, nodes will be processing their own events, hence we will be handling drag event in <strong>Node</strong> class. One important thing to note here is that we should be “using” the drag event with <strong>Use()</strong> method. Later on, we will be adding canvas dragging, and we wouldn’t want to drag a node and the whole canvas at the same time (“using” an event prevents it being used by other processes, i.e. it stops event bubbling). Also note that the for loop in <strong>ProcessNodeEvents(Event e)</strong> traverses the node list backwards, because the last node is drawn at the top, so it should process the events first.</p><pre class=" language-csharp  line-numbers "><code>using System;
using UnityEditor;
using UnityEngine;

public class Node
{
    public Rect rect;
    public string title;
    public bool isDragged;

    public GUIStyle style;

    public Node(Vector2 position, float width, float height, GUIStyle nodeStyle)
    {
        rect = new Rect(position.x, position.y, width, height);
        style = nodeStyle;
    }

    public void Drag(Vector2 delta)
    {
        rect.position += delta;
    }

    public void Draw()
    {
        GUI.Box(rect, title, style);
    }

    public bool ProcessEvents(Event e)
    {
        switch (e.type)
        {
            case EventType.MouseDown:
                if (e.button == 0)
                {
                    if (rect.Contains(e.mousePosition))
                    {
                        isDragged = true;
                        GUI.changed = true;
                    }
                    else
                    {
                        GUI.changed = true;
                    }
                }
                break;

            case EventType.MouseUp:
                isDragged = false;
                break;

            case EventType.MouseDrag:
                if (e.button == 0 &amp;amp;&amp;amp; isDragged)
                {
                    Drag(e.delta);
                    e.Use();
                    return true;
                }
                break;
        }

        return false;
    }
}</code></pre><pre class=" language-csharp  line-numbers "><code>    private void OnGUI()
    {
        DrawNodes();

        ProcessNodeEvents(Event.current);
        ProcessEvents(Event.current);

        if (GUI.changed) Repaint();
    }

    private void DrawNodes()
    {
        if (nodes != null)
        {
            for (int i = 0; i &lt; nodes.Count; i++)
            {
                nodes[i].Draw();
            }
        }
    }

    private void ProcessEvents(Event e)
    {
        switch (e.type)
        {
            case EventType.MouseDown:
                if (e.button == 1)
                {
                    ProcessContextMenu(e.mousePosition);
                }
                break;
        }
    }

    private void ProcessNodeEvents(Event e)
    {
        if (nodes != null)
        {
            for (int i = nodes.Count - 1; i &gt;= 0; i--)
            {
                bool guiChanged = nodes[i].ProcessEvents(e);

                if (guiChanged)
                {
                    GUI.changed = true;
                }
            }
        }
    }
	
    private void ProcessContextMenu(Vector2 mousePosition)
    {
        GenericMenu genericMenu = new GenericMenu();
        genericMenu.AddItem(new GUIContent(&quot;Add node&quot;), false, () =&gt; OnClickAddNode(mousePosition)); 
        genericMenu.ShowAsContext();
    }</code></pre>
<h3 id="creating-connections-between-nodes">Creating Connections Between Nodes</h3>
<p>Our node editor now has nodes, but we should also be able to connect them. In order to do this, we need two connection points (in and out) on a node and a connection between them. A connection point has a rectangle (so that we can draw it), has a type (in or out), has a style and it references its parent node. Therefore, our <strong>ConnectionPoint</strong> class will be a very simple one; drawing a button at a specific position and doing an action when this button is clicked.</p>
<p>On the other hand, a connection has two connection points and an action to remove it. <strong>Connection</strong> class is much simpler than <strong>ConnectionPoint</strong>, however, it introduces a new concept: <strong>Handles</strong>. This class is actually used to draw 3D GUI controls in the <strong>Scene</strong> view, but it is the only class with a bezier drawing method: <strong>Handles.DrawBezier(Vector3, Vector3, Vector3, Vector3, Color, Texture2D, float).</strong> It takes 7 parameters and the first 4 parameters are the position controls (start position, end position, start tangent, and end tangent), while the rest determine how the bezier looks.</p><pre class=" language-csharp  line-numbers "><code>using System;
using UnityEngine;

public enum ConnectionPointType { In, Out }

public class ConnectionPoint
{
    public Rect rect;

    public ConnectionPointType type;

    public Node node;

    public GUIStyle style;

    public Action&lt;ConnectionPoint&gt; OnClickConnectionPoint;
    
    public ConnectionPoint(Node node, ConnectionPointType type, GUIStyle style, Action&lt;ConnectionPoint&gt; OnClickConnectionPoint)
    {
        this.node = node;
        this.type = type;
        this.style = style;
        this.OnClickConnectionPoint = OnClickConnectionPoint;
        rect = new Rect(0, 0, 10f, 20f);
    }

    public void Draw()
    {
        rect.y = node.rect.y + (node.rect.height * 0.5f) - rect.height * 0.5f;

        switch (type)
        {
            case ConnectionPointType.In:
                rect.x = node.rect.x - rect.width + 8f;
                break;

            case ConnectionPointType.Out:
                rect.x = node.rect.x + node.rect.width - 8f;
                break;
        }
        
        if (GUI.Button(rect, &quot;&quot;, style))
        {
            if (OnClickConnectionPoint != null)
            {
                OnClickConnectionPoint(this);
            }
        }
    }
}</code></pre><pre class=" language-csharp  line-numbers "><code>using System;
using UnityEditor;
using UnityEngine;

public class Connection
{
    public ConnectionPoint inPoint;
    public ConnectionPoint outPoint;
    public Action&lt;Connection&gt; OnClickRemoveConnection;

    public Connection(ConnectionPoint inPoint, ConnectionPoint outPoint, Action&lt;Connection&gt; OnClickRemoveConnection)
    {
        this.inPoint = inPoint;
        this.outPoint = outPoint;
        this.OnClickRemoveConnection = OnClickRemoveConnection;
    }

    public void Draw()
    {
        Handles.DrawBezier(
            inPoint.rect.center,
            outPoint.rect.center,
            inPoint.rect.center + Vector2.left * 50f,
            outPoint.rect.center - Vector2.left * 50f,
            Color.white,
            null,
            2f
        );

        if (Handles.Button((inPoint.rect.center + outPoint.rect.center) * 0.5f, Quaternion.identity, 4, 8, Handles.RectangleCap))
        {
            if (OnClickRemoveConnection != null)
            {
                OnClickRemoveConnection(this);
            }
        }
    }
}</code></pre>
<h3 id="drawing-connections">Drawing Connections</h3>
<p>Since the <strong>Connection</strong> and <strong>ConnectionPoint</strong> classes are ready, all we have to do is draw connection points in <strong>Node</strong> class and draw connections in <strong>NodeBasedEditor</strong>. Changes in <strong>Node</strong> class will be minimal; we will define two connection points, modify the constructor so that we can pass the styling and actions for them, and draw them in <strong>Draw()</strong> method.</p>
<p>However, <strong>NodeBasedEditor</strong> needs significant modification. First of all, we need to define styles for connection points. You can use a single style for both of them, but I would like them to look different, so I will be using separate styles for each. We are going to initialize these styles in <strong>OnEnable()</strong> just like we initialized node style.</p>
<p>Secondly, we need to keep track of clicked connection points, so that when a user selects an <strong>in</strong> and <strong>out</strong>, we should create a connection between them. This step includes most of the additions:</p>
<ul>
 <li>OnClickInPoint(ConnectionPoint) handles clicking an <strong>in</strong> point.</li>
 <li>OnClickOutPoint(ConnectionPoint) handles clicking an <strong>out</strong> point.</li>
 <li>OnClickRemoveConnection(Connection) handles clicking the remove button on connections.</li>
 <li>CreateConnection() creates a connection when an <strong>in</strong> and an <strong>out</strong> point is selected.</li>
 <li>ClearConnectionSelection() clears selected points.</li>
</ul>
<p>And lastly, we need to draw connections in <strong>OnGUI()</strong> just like we draw nodes.</p><pre class=" language-csharp  line-numbers "><code>using System;
using UnityEditor;
using UnityEngine;

public class Node
{
    public Rect rect;
    public string title;
    public bool isDragged;

    public ConnectionPoint inPoint;
    public ConnectionPoint outPoint;

    public GUIStyle style;

    public Node(Vector2 position, float width, float height, GUIStyle nodeStyle, GUIStyle inPointStyle, GUIStyle outPointStyle, Action&lt;ConnectionPoint&gt; OnClickInPoint, Action&lt;ConnectionPoint&gt; OnClickOutPoint)
    {
        rect = new Rect(position.x, position.y, width, height);
        style = nodeStyle;
        inPoint = new ConnectionPoint(this, ConnectionPointType.In, inPointStyle, OnClickInPoint);
        outPoint = new ConnectionPoint(this, ConnectionPointType.Out, outPointStyle, OnClickOutPoint);
    }

    public void Drag(Vector2 delta)
    {
        rect.position += delta;
    }

    public void Draw()
    {
        inPoint.Draw();
        outPoint.Draw();
        GUI.Box(rect, title, style);
    }

    public bool ProcessEvents(Event e)
    {
        switch (e.type)
        {
            case EventType.MouseDown:
                if (e.button == 0)
                {
                    if (rect.Contains(e.mousePosition))
                    {
                        isDragged = true;
                        GUI.changed = true;
                    }
                    else
                    {
                        GUI.changed = true;
                    }
                }
                break;

            case EventType.MouseUp:
                isDragged = false;
                break;

            case EventType.MouseDrag:
                if (e.button == 0 &amp;amp;&amp;amp; isDragged)
                {
                    Drag(e.delta);
                    e.Use();
                    return true;
                }
                break;
        }

        return false;
    }
}</code></pre><pre class=" language-csharp  line-numbers "><code>using UnityEngine;
using UnityEditor;
using System.Collections.Generic;

public class NodeBasedEditor : EditorWindow
{
    private List&lt;Node&gt; nodes;
    private List&lt;Connection&gt; connections;

    private GUIStyle nodeStyle;
    private GUIStyle inPointStyle;
    private GUIStyle outPointStyle;

    private ConnectionPoint selectedInPoint;
    private ConnectionPoint selectedOutPoint;

    [MenuItem(&quot;Window/Node Based Editor&quot;)]
    private static void OpenWindow()
    {
        NodeBasedEditor window = GetWindow&lt;NodeBasedEditor&gt;();
        window.titleContent = new GUIContent(&quot;Node Based Editor&quot;);
    }

    private void OnEnable()
    {
        nodeStyle = new GUIStyle();
        nodeStyle.normal.background = EditorGUIUtility.Load(&quot;builtin skins/darkskin/images/node1.png&quot;) as Texture2D;
        nodeStyle.border = new RectOffset(12, 12, 12, 12);
		
        inPointStyle = new GUIStyle();
        inPointStyle.normal.background = EditorGUIUtility.Load(&quot;builtin skins/darkskin/images/btn left.png&quot;) as Texture2D;
        inPointStyle.active.background = EditorGUIUtility.Load(&quot;builtin skins/darkskin/images/btn left on.png&quot;) as Texture2D;
        inPointStyle.border = new RectOffset(4, 4, 12, 12);

        outPointStyle = new GUIStyle();
        outPointStyle.normal.background = EditorGUIUtility.Load(&quot;builtin skins/darkskin/images/btn right.png&quot;) as Texture2D;
        outPointStyle.active.background = EditorGUIUtility.Load(&quot;builtin skins/darkskin/images/btn right on.png&quot;) as Texture2D;
        outPointStyle.border = new RectOffset(4, 4, 12, 12);
    }

    private void OnGUI()
    {
        DrawNodes();
        DrawConnections();

        ProcessNodeEvents(Event.current);
        ProcessEvents(Event.current);

        if (GUI.changed) Repaint();
    }

    private void DrawNodes()
    {
        if (nodes != null)
        {
            for (int i = 0; i &lt; nodes.Count; i++)
            {
                nodes[i].Draw();
            }
        }
    }

    private void DrawConnections()
    {
        if (connections != null)
        {
            for (int i = 0; i &lt; connections.Count; i++)
            {
                connections[i].Draw();
            } 
        }
    }

    private void ProcessEvents(Event e)
    {
        switch (e.type)
        {
            case EventType.MouseDown:
                if (e.button == 0)
                {
                    ClearConnectionSelection();
                }

                if (e.button == 1)
                {
                    ProcessContextMenu(e.mousePosition);
                }
                break;
        }
    }

    private void ProcessNodeEvents(Event e)
    {
        if (nodes != null)
        {
            for (int i = nodes.Count - 1; i &gt;= 0; i--)
            {
                bool guiChanged = nodes[i].ProcessEvents(e);

                if (guiChanged)
                {
                    GUI.changed = true;
                }
            }
        }
    }
	
    private void ProcessContextMenu(Vector2 mousePosition)
    {
        GenericMenu genericMenu = new GenericMenu();
        genericMenu.AddItem(new GUIContent(&quot;Add node&quot;), false, () =&gt; OnClickAddNode(mousePosition)); 
        genericMenu.ShowAsContext();
    }

    private void OnClickAddNode(Vector2 mousePosition)
    {
        if (nodes == null)
        {
            nodes = new List&lt;Node&gt;();
        }

        nodes.Add(new Node(mousePosition, 200, 50, nodeStyle, inPointStyle, outPointStyle, OnClickInPoint, OnClickOutPoint));
    }

    private void OnClickInPoint(ConnectionPoint inPoint)
    {
        selectedInPoint = inPoint;

        if (selectedOutPoint != null)
        {
            if (selectedOutPoint.node != selectedInPoint.node)
            {
                CreateConnection();
                ClearConnectionSelection(); 
            }
            else
            {
                ClearConnectionSelection();
            }
        }
    }

    private void OnClickOutPoint(ConnectionPoint outPoint)
    {
        selectedOutPoint = outPoint;

        if (selectedInPoint != null)
        {
            if (selectedOutPoint.node != selectedInPoint.node)
            {
                CreateConnection();
                ClearConnectionSelection();
            }
            else
            {
                ClearConnectionSelection();
            }
        }
    }

    private void OnClickRemoveConnection(Connection connection)
    {
        connections.Remove(connection);
    }

    private void CreateConnection()
    {
        if (connections == null)
        {
            connections = new List&lt;Connection&gt;();
        }

        connections.Add(new Connection(selectedInPoint, selectedOutPoint, OnClickRemoveConnection));
    }

    private void ClearConnectionSelection()
    {
        selectedInPoint = null;
        selectedOutPoint = null;
    }
}</code></pre>
<h3 id="selecting-nodes">Selecting Nodes</h3>
<p>We should provide feedback when the user clicks on a node so that they would know which node they selected (or if a node is selected at all). This is going to be useful when a user wants to remove a node.</p><pre class=" language-csharp  line-numbers "><code>using System;
using UnityEditor;
using UnityEngine;

public class Node
{
    public Rect rect;
    public string title;
    public bool isDragged;
    public bool isSelected;

    public ConnectionPoint inPoint;
    public ConnectionPoint outPoint;

    public GUIStyle style;
    public GUIStyle defaultNodeStyle;
    public GUIStyle selectedNodeStyle;

    public Node(Vector2 position, float width, float height, GUIStyle nodeStyle, GUIStyle selectedStyle, GUIStyle inPointStyle, GUIStyle outPointStyle, Action&lt;ConnectionPoint&gt; OnClickInPoint, Action&lt;ConnectionPoint&gt; OnClickOutPoint)
    {
        rect = new Rect(position.x, position.y, width, height);
        style = nodeStyle;
        inPoint = new ConnectionPoint(this, ConnectionPointType.In, inPointStyle, OnClickInPoint);
        outPoint = new ConnectionPoint(this, ConnectionPointType.Out, outPointStyle, OnClickOutPoint);
        defaultNodeStyle = nodeStyle;
        selectedNodeStyle = selectedStyle;
    }

    public void Drag(Vector2 delta)
    {
        rect.position += delta;
    }

    public void Draw()
    {
        inPoint.Draw();
        outPoint.Draw();
        GUI.Box(rect, title, style);
    }

    public bool ProcessEvents(Event e)
    {
        switch (e.type)
        {
            case EventType.MouseDown:
                if (e.button == 0)
                {
                    if (rect.Contains(e.mousePosition))
                    {
                        isDragged = true;
                        GUI.changed = true;
                        isSelected = true;
                        style = selectedNodeStyle;
                    }
                    else
                    {
                        GUI.changed = true;
                        isSelected = false;
                        style = defaultNodeStyle;
                    }
                }
                break;

            case EventType.MouseUp:
                isDragged = false;
                break;

            case EventType.MouseDrag:
                if (e.button == 0 &amp;amp;&amp;amp; isDragged)
                {
                    Drag(e.delta);
                    e.Use();
                    return true;
                }
                break;
        }

        return false;
    }
}</code></pre><pre class=" language-csharp  line-numbers "><code>using UnityEngine;
using UnityEditor;
using System.Collections.Generic;

public class NodeBasedEditor : EditorWindow
{
    private List&lt;Node&gt; nodes;
    private List&lt;Connection&gt; connections;

    private GUIStyle nodeStyle;
    private GUIStyle selectedNodeStyle;
    private GUIStyle inPointStyle;
    private GUIStyle outPointStyle;

    private ConnectionPoint selectedInPoint;
    private ConnectionPoint selectedOutPoint;

    [MenuItem(&quot;Window/Node Based Editor&quot;)]
    private static void OpenWindow()
    {
        NodeBasedEditor window = GetWindow&lt;NodeBasedEditor&gt;();
        window.titleContent = new GUIContent(&quot;Node Based Editor&quot;);
    }

    private void OnEnable()
    {
        nodeStyle = new GUIStyle();
        nodeStyle.normal.background = EditorGUIUtility.Load(&quot;builtin skins/darkskin/images/node1.png&quot;) as Texture2D;
        nodeStyle.border = new RectOffset(12, 12, 12, 12);

        selectedNodeStyle = new GUIStyle();
        selectedNodeStyle.normal.background = EditorGUIUtility.Load(&quot;builtin skins/darkskin/images/node1 on.png&quot;) as Texture2D;
        selectedNodeStyle.border = new RectOffset(12, 12, 12, 12);

        inPointStyle = new GUIStyle();
        inPointStyle.normal.background = EditorGUIUtility.Load(&quot;builtin skins/darkskin/images/btn left.png&quot;) as Texture2D;
        inPointStyle.active.background = EditorGUIUtility.Load(&quot;builtin skins/darkskin/images/btn left on.png&quot;) as Texture2D;
        inPointStyle.border = new RectOffset(4, 4, 12, 12);

        outPointStyle = new GUIStyle();
        outPointStyle.normal.background = EditorGUIUtility.Load(&quot;builtin skins/darkskin/images/btn right.png&quot;) as Texture2D;
        outPointStyle.active.background = EditorGUIUtility.Load(&quot;builtin skins/darkskin/images/btn right on.png&quot;) as Texture2D;
        outPointStyle.border = new RectOffset(4, 4, 12, 12);
    }

    ...</code></pre><pre class=" language-csharp  line-numbers "><code>    private void OnClickAddNode(Vector2 mousePosition)
    {
        if (nodes == null)
        {
            nodes = new List&lt;Node&gt;();
        }

        nodes.Add(new Node(mousePosition, 200, 50, nodeStyle, selectedNodeStyle, inPointStyle, outPointStyle, OnClickInPoint, OnClickOutPoint));
    }</code></pre>
<h3 id="removing-nodes">Removing Nodes</h3>
<p>Some node editors prefer to put the <strong>remove node</strong> button on the node itself, but in our case it might be dangerous: the user might remove a node accidentally. So, we are going to do the next best thing: put that button on a context menu. Users should select the node first and then right click on it in order to access the <strong>remove node</strong> button. When the user clicks <strong>remove node</strong>, we will remove the node from the nodes list. However, the node might have connections to other nodes, so we should remove those connections first.</p><pre class=" language-csharp  line-numbers "><code>using System;
using UnityEditor;
using UnityEngine;

public class Node
{
    public Rect rect;
    public string title;
    public bool isDragged;
    public bool isSelected;

    public ConnectionPoint inPoint;
    public ConnectionPoint outPoint;

    public GUIStyle style;
    public GUIStyle defaultNodeStyle;
    public GUIStyle selectedNodeStyle;

    public Action&lt;Node&gt; OnRemoveNode;

    public Node(Vector2 position, float width, float height, GUIStyle nodeStyle, GUIStyle selectedStyle, GUIStyle inPointStyle, GUIStyle outPointStyle, Action&lt;ConnectionPoint&gt; OnClickInPoint, Action&lt;ConnectionPoint&gt; OnClickOutPoint, Action&lt;Node&gt; OnClickRemoveNode)
    {
        rect = new Rect(position.x, position.y, width, height);
        style = nodeStyle;
        inPoint = new ConnectionPoint(this, ConnectionPointType.In, inPointStyle, OnClickInPoint);
        outPoint = new ConnectionPoint(this, ConnectionPointType.Out, outPointStyle, OnClickOutPoint);
        defaultNodeStyle = nodeStyle;
        selectedNodeStyle = selectedStyle;
        OnRemoveNode = OnClickRemoveNode;
    }

    public void Drag(Vector2 delta)
    {
        rect.position += delta;
    }

    public void Draw()
    {
        inPoint.Draw();
        outPoint.Draw();
        GUI.Box(rect, title, style);
    }

    public bool ProcessEvents(Event e)
    {
        switch (e.type)
        {
            case EventType.MouseDown:
                if (e.button == 0)
                {
                    if (rect.Contains(e.mousePosition))
                    {
                        isDragged = true;
                        GUI.changed = true;
                        isSelected = true;
                        style = selectedNodeStyle;
                    }
                    else
                    {
                        GUI.changed = true;
                        isSelected = false;
                        style = defaultNodeStyle;
                    }
                }

                if (e.button == 1 &amp;amp;&amp;amp; isSelected &amp;amp;&amp;amp; rect.Contains(e.mousePosition))
                {
                    ProcessContextMenu();
                    e.Use();
                }
                break;

            case EventType.MouseUp:
                isDragged = false;
                break;

            case EventType.MouseDrag:
                if (e.button == 0 &amp;amp;&amp;amp; isDragged)
                {
                    Drag(e.delta);
                    e.Use();
                    return true;
                }
                break;
        }

        return false;
    }

    private void ProcessContextMenu()
    {
        GenericMenu genericMenu = new GenericMenu();
        genericMenu.AddItem(new GUIContent(&quot;Remove node&quot;), false, OnClickRemoveNode);
        genericMenu.ShowAsContext();
    }

    private void OnClickRemoveNode()
    {
        if (OnRemoveNode != null)
        {
            OnRemoveNode(this);
        }
    }
}</code></pre><pre class=" language-csharp  line-numbers "><code>    private void OnClickAddNode(Vector2 mousePosition)
    {
        if (nodes == null)
        {
            nodes = new List&lt;Node&gt;();
        }

        nodes.Add(new Node(mousePosition, 200, 50, nodeStyle, selectedNodeStyle, inPointStyle, outPointStyle, OnClickInPoint, OnClickOutPoint, OnClickRemoveNode));
    }</code></pre><pre class=" language-csharp  line-numbers "><code>    private void OnClickRemoveNode(Node node)
    {
        if (connections != null)
        {
            List&lt;Connection&gt; connectionsToRemove = new List&lt;Connection&gt;();

            for (int i = 0; i &lt; connections.Count; i++)
            {
                if (connections[i].inPoint == node.inPoint || connections[i].outPoint == node.outPoint)
                {
                    connectionsToRemove.Add(connections[i]);
                }
            }

            for (int i = 0; i &lt; connectionsToRemove.Count; i++)
            {
                connections.Remove(connectionsToRemove[i]);
            }

            connectionsToRemove = null;
        }

        nodes.Remove(node);
    }</code></pre>
<h3 id="final-touches">Final Touches</h3>
<p>The node editor is complete at this point, but it lacks some important features which would elevate the user experience:</p>
<ul>
 <li>A draggable canvas,</li>
 <li>A bezier from selected connection point to the mouse position,</li>
 <li>A grid in the background.</li>
</ul>
<p>Making our canvas draggable is the easiest one, so let’s start with that. All we have to do is just apply mouse drag to every single node in the node list.</p><pre class=" language-csharp  line-numbers "><code>public class NodeBasedEditor : EditorWindow
{
    private List&lt;Node&gt; nodes;
    private List&lt;Connection&gt; connections;

    private GUIStyle nodeStyle;
    private GUIStyle selectedNodeStyle;
    private GUIStyle inPointStyle;
    private GUIStyle outPointStyle;

    private ConnectionPoint selectedInPoint;
    private ConnectionPoint selectedOutPoint;
    
    private Vector2 drag;

    ...</code></pre><pre class=" language-csharp  line-numbers "><code>    private void ProcessEvents(Event e)
    {
        drag = Vector2.zero;

        switch (e.type)
        {
            case EventType.MouseDown:
                if (e.button == 0)
                {
                    ClearConnectionSelection();
                }

                if (e.button == 1)
                {
                    ProcessContextMenu(e.mousePosition);
                }
            break;

            case EventType.MouseDrag:
                if (e.button == 0)
                {
                    OnDrag(e.delta);
                }
            break;
        }
    }</code></pre><pre class=" language-csharp  line-numbers "><code>    private void OnDrag(Vector2 delta)
    {
        drag = delta;

        if (nodes != null)
        {
            for (int i = 0; i &lt; nodes.Count; i++)
            {
                nodes[i].Drag(delta);
            }
        }

        GUI.changed = true;
    }</code></pre>
<p>Next up, drawing the bezier from selected connection point to the mouse position. By drawing this bezier, we will let users know which connection point selected and how their connection will look like.</p><pre class=" language-csharp  line-numbers "><code>    private void OnGUI()
    {
        DrawNodes();
        DrawConnections();

        DrawConnectionLine(Event.current);

        ProcessNodeEvents(Event.current);
        ProcessEvents(Event.current);

        if (GUI.changed) Repaint();
    }</code></pre><pre class=" language-csharp  line-numbers "><code>    private void DrawConnectionLine(Event e)
    {
        if (selectedInPoint != null &amp;amp;&amp;amp; selectedOutPoint == null)
        {
            Handles.DrawBezier(
                selectedInPoint.rect.center,
                e.mousePosition,
                selectedInPoint.rect.center + Vector2.left * 50f,
                e.mousePosition - Vector2.left * 50f,
                Color.white,
                null,
                2f
            );

            GUI.changed = true;
        }

        if (selectedOutPoint != null &amp;amp;&amp;amp; selectedInPoint == null)
        {
            Handles.DrawBezier(
                selectedOutPoint.rect.center,
                e.mousePosition,
                selectedOutPoint.rect.center - Vector2.left * 50f,
                e.mousePosition + Vector2.left * 50f,
                Color.white,
                null,
                2f
            );

            GUI.changed = true;
        }
    }</code></pre>
<p>And finally, drawing the grid:</p><pre class=" language-csharp  line-numbers "><code>public class NodeBasedEditor : EditorWindow
{
    private List&lt;Node&gt; nodes;
    private List&lt;Connection&gt; connections;

    private GUIStyle nodeStyle;
    private GUIStyle selectedNodeStyle;
    private GUIStyle inPointStyle;
    private GUIStyle outPointStyle;

    private ConnectionPoint selectedInPoint;
    private ConnectionPoint selectedOutPoint;

    private Vector2 offset;
    private Vector2 drag;

    ...</code></pre><pre class=" language-csharp  line-numbers "><code>    private void OnGUI()
    {
        DrawGrid(20, 0.2f, Color.gray);
        DrawGrid(100, 0.4f, Color.gray);

        DrawNodes();
        DrawConnections();

        DrawConnectionLine(Event.current);

        ProcessNodeEvents(Event.current);
        ProcessEvents(Event.current);

        if (GUI.changed) Repaint();
    }

    private void DrawGrid(float gridSpacing, float gridOpacity, Color gridColor)
    {
        int widthDivs = Mathf.CeilToInt(position.width / gridSpacing);
        int heightDivs = Mathf.CeilToInt(position.height / gridSpacing);

        Handles.BeginGUI();
        Handles.color = new Color(gridColor.r, gridColor.g, gridColor.b, gridOpacity);

        offset += drag * 0.5f;
        Vector3 newOffset = new Vector3(offset.x % gridSpacing, offset.y % gridSpacing, 0);

        for (int i = 0; i &lt; widthDivs; i++)
        {
            Handles.DrawLine(new Vector3(gridSpacing * i, -gridSpacing, 0) + newOffset, new Vector3(gridSpacing * i, position.height, 0f) + newOffset);
        }

        for (int j = 0; j &lt; heightDivs; j++)
        {
            Handles.DrawLine(new Vector3(-gridSpacing, gridSpacing * j, 0) + newOffset, new Vector3(position.width, gridSpacing * j, 0f) + newOffset);
        }

        Handles.color = Color.white;
        Handles.EndGUI();
    }</code></pre>
<h3 id="conclusion">Conclusion</h3>
<p>This concludes our tutorial and to be frank, our node editor looks like any first grade node editor you can find on the Asset Store. From this point on, you can work on it and create your own custom node editor. Here is a quest editor I built while working on a prototype:</p>
<div class="img-wrapper">
        <img src="/assets/img/sample-node-based-editor.png" class="center" alt="Sample Node Based Editor" width="400px" />
   <div class="empty-caption"></div>
</div>
<p>And as always, here is the script in full, below. Until next time.</p><pre class=" language-csharp  line-numbers "><code>using UnityEngine;
using UnityEditor;
using System.Collections.Generic;

public class NodeBasedEditor : EditorWindow
{
    private List&lt;Node&gt; nodes;
    private List&lt;Connection&gt; connections;

    private GUIStyle nodeStyle;
    private GUIStyle selectedNodeStyle;
    private GUIStyle inPointStyle;
    private GUIStyle outPointStyle;

    private ConnectionPoint selectedInPoint;
    private ConnectionPoint selectedOutPoint;

    private Vector2 offset;
    private Vector2 drag;

    [MenuItem(&quot;Window/Node Based Editor&quot;)]
    private static void OpenWindow()
    {
        NodeBasedEditor window = GetWindow&lt;NodeBasedEditor&gt;();
        window.titleContent = new GUIContent(&quot;Node Based Editor&quot;);
    }

    private void OnEnable()
    {
        nodeStyle = new GUIStyle();
        nodeStyle.normal.background = EditorGUIUtility.Load(&quot;builtin skins/darkskin/images/node1.png&quot;) as Texture2D;
        nodeStyle.border = new RectOffset(12, 12, 12, 12);

        selectedNodeStyle = new GUIStyle();
        selectedNodeStyle.normal.background = EditorGUIUtility.Load(&quot;builtin skins/darkskin/images/node1 on.png&quot;) as Texture2D;
        selectedNodeStyle.border = new RectOffset(12, 12, 12, 12);

        inPointStyle = new GUIStyle();
        inPointStyle.normal.background = EditorGUIUtility.Load(&quot;builtin skins/darkskin/images/btn left.png&quot;) as Texture2D;
        inPointStyle.active.background = EditorGUIUtility.Load(&quot;builtin skins/darkskin/images/btn left on.png&quot;) as Texture2D;
        inPointStyle.border = new RectOffset(4, 4, 12, 12);

        outPointStyle = new GUIStyle();
        outPointStyle.normal.background = EditorGUIUtility.Load(&quot;builtin skins/darkskin/images/btn right.png&quot;) as Texture2D;
        outPointStyle.active.background = EditorGUIUtility.Load(&quot;builtin skins/darkskin/images/btn right on.png&quot;) as Texture2D;
        outPointStyle.border = new RectOffset(4, 4, 12, 12);
    }

    private void OnGUI()
    {
        DrawGrid(20, 0.2f, Color.gray);
        DrawGrid(100, 0.4f, Color.gray);

        DrawNodes();
        DrawConnections();

        DrawConnectionLine(Event.current);

        ProcessNodeEvents(Event.current);
        ProcessEvents(Event.current);

        if (GUI.changed) Repaint();
    }

    private void DrawGrid(float gridSpacing, float gridOpacity, Color gridColor)
    {
        int widthDivs = Mathf.CeilToInt(position.width / gridSpacing);
        int heightDivs = Mathf.CeilToInt(position.height / gridSpacing);

        Handles.BeginGUI();
        Handles.color = new Color(gridColor.r, gridColor.g, gridColor.b, gridOpacity);

        offset += drag * 0.5f;
        Vector3 newOffset = new Vector3(offset.x % gridSpacing, offset.y % gridSpacing, 0);

        for (int i = 0; i &lt; widthDivs; i++)
        {
            Handles.DrawLine(new Vector3(gridSpacing * i, -gridSpacing, 0) + newOffset, new Vector3(gridSpacing * i, position.height, 0f) + newOffset);
        }

        for (int j = 0; j &lt; heightDivs; j++)
        {
            Handles.DrawLine(new Vector3(-gridSpacing, gridSpacing * j, 0) + newOffset, new Vector3(position.width, gridSpacing * j, 0f) + newOffset);
        }

        Handles.color = Color.white;
        Handles.EndGUI();
    }

    private void DrawNodes()
    {
        if (nodes != null)
        {
            for (int i = 0; i &lt; nodes.Count; i++)
            {
                nodes[i].Draw();
            }
        }
    }

    private void DrawConnections()
    {
        if (connections != null)
        {
            for (int i = 0; i &lt; connections.Count; i++)
            {
                connections[i].Draw();
            } 
        }
    }

    private void ProcessEvents(Event e)
    {
        drag = Vector2.zero;

        switch (e.type)
        {
            case EventType.MouseDown:
                if (e.button == 0)
                {
                    ClearConnectionSelection();
                }

                if (e.button == 1)
                {
                    ProcessContextMenu(e.mousePosition);
                }
            break;

            case EventType.MouseDrag:
                if (e.button == 0)
                {
                    OnDrag(e.delta);
                }
            break;
        }
    }

    private void ProcessNodeEvents(Event e)
    {
        if (nodes != null)
        {
            for (int i = nodes.Count - 1; i &gt;= 0; i--)
            {
                bool guiChanged = nodes[i].ProcessEvents(e);

                if (guiChanged)
                {
                    GUI.changed = true;
                }
            }
        }
    }

    private void DrawConnectionLine(Event e)
    {
        if (selectedInPoint != null &amp;amp;&amp;amp; selectedOutPoint == null)
        {
            Handles.DrawBezier(
                selectedInPoint.rect.center,
                e.mousePosition,
                selectedInPoint.rect.center + Vector2.left * 50f,
                e.mousePosition - Vector2.left * 50f,
                Color.white,
                null,
                2f
            );

            GUI.changed = true;
        }

        if (selectedOutPoint != null &amp;amp;&amp;amp; selectedInPoint == null)
        {
            Handles.DrawBezier(
                selectedOutPoint.rect.center,
                e.mousePosition,
                selectedOutPoint.rect.center - Vector2.left * 50f,
                e.mousePosition + Vector2.left * 50f,
                Color.white,
                null,
                2f
            );

            GUI.changed = true;
        }
    }

    private void ProcessContextMenu(Vector2 mousePosition)
    {
        GenericMenu genericMenu = new GenericMenu();
        genericMenu.AddItem(new GUIContent(&quot;Add node&quot;), false, () =&gt; OnClickAddNode(mousePosition)); 
        genericMenu.ShowAsContext();
    }

    private void OnDrag(Vector2 delta)
    {
        drag = delta;

        if (nodes != null)
        {
            for (int i = 0; i &lt; nodes.Count; i++)
            {
                nodes[i].Drag(delta);
            }
        }

        GUI.changed = true;
    }

    private void OnClickAddNode(Vector2 mousePosition)
    {
        if (nodes == null)
        {
            nodes = new List&lt;Node&gt;();
        }

        nodes.Add(new Node(mousePosition, 200, 50, nodeStyle, selectedNodeStyle, inPointStyle, outPointStyle, OnClickInPoint, OnClickOutPoint, OnClickRemoveNode));
    }

    private void OnClickInPoint(ConnectionPoint inPoint)
    {
        selectedInPoint = inPoint;

        if (selectedOutPoint != null)
        {
            if (selectedOutPoint.node != selectedInPoint.node)
            {
                CreateConnection();
                ClearConnectionSelection(); 
            }
            else
            {
                ClearConnectionSelection();
            }
        }
    }

    private void OnClickOutPoint(ConnectionPoint outPoint)
    {
        selectedOutPoint = outPoint;

        if (selectedInPoint != null)
        {
            if (selectedOutPoint.node != selectedInPoint.node)
            {
                CreateConnection();
                ClearConnectionSelection();
            }
            else
            {
                ClearConnectionSelection();
            }
        }
    }

    private void OnClickRemoveNode(Node node)
    {
        if (connections != null)
        {
            List&lt;Connection&gt; connectionsToRemove = new List&lt;Connection&gt;();

            for (int i = 0; i &lt; connections.Count; i++)
            {
                if (connections[i].inPoint == node.inPoint || connections[i].outPoint == node.outPoint)
                {
                    connectionsToRemove.Add(connections[i]);
                }
            }

            for (int i = 0; i &lt; connectionsToRemove.Count; i++)
            {
                connections.Remove(connectionsToRemove[i]);
            }

            connectionsToRemove = null;
        }

        nodes.Remove(node);
    }

    private void OnClickRemoveConnection(Connection connection)
    {
        connections.Remove(connection);
    }

    private void CreateConnection()
    {
        if (connections == null)
        {
            connections = new List&lt;Connection&gt;();
        }

        connections.Add(new Connection(selectedInPoint, selectedOutPoint, OnClickRemoveConnection));
    }

    private void ClearConnectionSelection()
    {
        selectedInPoint = null;
        selectedOutPoint = null;
    }
}</code></pre><pre class=" language-csharp  line-numbers "><code>using System;
using UnityEditor;
using UnityEngine;

public class Node
{
    public Rect rect;
    public string title;
    public bool isDragged;
    public bool isSelected;

    public ConnectionPoint inPoint;
    public ConnectionPoint outPoint;

    public GUIStyle style;
    public GUIStyle defaultNodeStyle;
    public GUIStyle selectedNodeStyle;

    public Action&lt;Node&gt; OnRemoveNode;

    public Node(Vector2 position, float width, float height, GUIStyle nodeStyle, GUIStyle selectedStyle, GUIStyle inPointStyle, GUIStyle outPointStyle, Action&lt;ConnectionPoint&gt; OnClickInPoint, Action&lt;ConnectionPoint&gt; OnClickOutPoint, Action&lt;Node&gt; OnClickRemoveNode)
    {
        rect = new Rect(position.x, position.y, width, height);
        style = nodeStyle;
        inPoint = new ConnectionPoint(this, ConnectionPointType.In, inPointStyle, OnClickInPoint);
        outPoint = new ConnectionPoint(this, ConnectionPointType.Out, outPointStyle, OnClickOutPoint);
        defaultNodeStyle = nodeStyle;
        selectedNodeStyle = selectedStyle;
        OnRemoveNode = OnClickRemoveNode;
    }

    public void Drag(Vector2 delta)
    {
        rect.position += delta;
    }

    public void Draw()
    {
        inPoint.Draw();
        outPoint.Draw();
        GUI.Box(rect, title, style);
    }

    public bool ProcessEvents(Event e)
    {
        switch (e.type)
        {
            case EventType.MouseDown:
                if (e.button == 0)
                {
                    if (rect.Contains(e.mousePosition))
                    {
                        isDragged = true;
                        GUI.changed = true;
                        isSelected = true;
                        style = selectedNodeStyle;
                    }
                    else
                    {
                        GUI.changed = true;
                        isSelected = false;
                        style = defaultNodeStyle;
                    }
                }

                if (e.button == 1 &amp;amp;&amp;amp; isSelected &amp;amp;&amp;amp; rect.Contains(e.mousePosition))
                {
                    ProcessContextMenu();
                    e.Use();
                }
                break;

            case EventType.MouseUp:
                isDragged = false;
                break;

            case EventType.MouseDrag:
                if (e.button == 0 &amp;amp;&amp;amp; isDragged)
                {
                    Drag(e.delta);
                    e.Use();
                    return true;
                }
                break;
        }

        return false;
    }

    private void ProcessContextMenu()
    {
        GenericMenu genericMenu = new GenericMenu();
        genericMenu.AddItem(new GUIContent(&quot;Remove node&quot;), false, OnClickRemoveNode);
        genericMenu.ShowAsContext();
    }

    private void OnClickRemoveNode()
    {
        if (OnRemoveNode != null)
        {
            OnRemoveNode(this);
        }
    }
}</code></pre><pre class=" language-csharp  line-numbers "><code>using System;
using UnityEditor;
using UnityEngine;

public class Connection
{
    public ConnectionPoint inPoint;
    public ConnectionPoint outPoint;
    public Action&lt;Connection&gt; OnClickRemoveConnection;

    public Connection(ConnectionPoint inPoint, ConnectionPoint outPoint, Action&lt;Connection&gt; OnClickRemoveConnection)
    {
        this.inPoint = inPoint;
        this.outPoint = outPoint;
        this.OnClickRemoveConnection = OnClickRemoveConnection;
    }

    public void Draw()
    {
        Handles.DrawBezier(
            inPoint.rect.center,
            outPoint.rect.center,
            inPoint.rect.center + Vector2.left * 50f,
            outPoint.rect.center - Vector2.left * 50f,
            Color.white,
            null,
            2f
        );

        if (Handles.Button((inPoint.rect.center + outPoint.rect.center) * 0.5f, Quaternion.identity, 4, 8, Handles.RectangleCap))
        {
            if (OnClickRemoveConnection != null)
            {
                OnClickRemoveConnection(this);
            }
        }
    }
}</code></pre><pre class=" language-csharp  line-numbers "><code>using System;
using UnityEngine;

public enum ConnectionPointType { In, Out }

public class ConnectionPoint
{
    public Rect rect;

    public ConnectionPointType type;

    public Node node;

    public GUIStyle style;

    public Action&lt;ConnectionPoint&gt; OnClickConnectionPoint;

    public ConnectionPoint(Node node, ConnectionPointType type, GUIStyle style, Action&lt;ConnectionPoint&gt; OnClickConnectionPoint)
    {
        this.node = node;
        this.type = type;
        this.style = style;
        this.OnClickConnectionPoint = OnClickConnectionPoint;
        rect = new Rect(0, 0, 10f, 20f);
    }

    public void Draw()
    {
        rect.y = node.rect.y + (node.rect.height * 0.5f) - rect.height * 0.5f;

        switch (type)
        {
            case ConnectionPointType.In:
            rect.x = node.rect.x - rect.width + 8f;
            break;

            case ConnectionPointType.Out:
            rect.x = node.rect.x + node.rect.width - 8f;
            break;
        }

        if (GUI.Button(rect, &quot;&quot;, style))
        {
            if (OnClickConnectionPoint != null)
            {
                OnClickConnectionPoint(this);
            }
        }
    }
}</code></pre>
 </div>
 <div class="post-footer">
<div class="post-filed">
 <p>
    Filed under
<a href="/category/unity/" rel="category">unity</a>,
<a href="/category/unity-editor/" rel="category">unity-editor</a>.
 </p>
 <p>
    <a href="#top">top&nbsp;&#8673;</a>
 </p>
</div>
<div class="post-nav">
 <p>
    <a href="/creating-clone-unitys-console-window/">&#8672;&nbsp;Creating a Clone of Unity's Console Window</a>
 </p>
 <p>
    <a href="/xml-serialization-and-deserialization-in-unity/">XML Serialization in Unity&nbsp;&#8674;</a>
 </p>
</div>
 </div>
 <div class="comments">
 <div id="disqus_thread"></div>
  <script>
    var disqus_config = function () {
      this.page.url = 'http://localhost:4000/creating-node-based-editor-unity/';
      this.page.identifier = 'http://localhost:4000/creating-node-based-editor-unity/';
    };
    (function() {
      var d = document, s = d.createElement('script');
      s.src = 'https://oguzkonya.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
 </div>
</article>
   </div>
 </main>
 <footer class="site-footer">
 <div class="wrapper-footer">
   <div class="footer-col-wrapper">
      <a href="/">home</a>
      •
      <a href="https://github.com/oguzkonya/oguzkonya.github.io"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">github</span></a>
      •
      <a href="/feed.xml">rss</a>
   </div>
   <div class="copyright">
      © 2019 oguzkonya
   </div>
 </div>
</footer>
  <script src="/assets/js/instantpage.js" type="module" defer integrity="sha384-D7B5eODAUd397+f4zNFAVlnDNDtO1ppV8rPnfygILQXhqu3cUndgHvlcJR2Bhig8"></script>
  <script src="/assets/js/prism.js"></script>
  <script id="dsq-count-scr" src="//oguzkonya.disqus.com/count.js" async></script>
</body>
</html>
