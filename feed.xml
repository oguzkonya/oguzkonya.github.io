<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="https://oguzkonya.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://oguzkonya.github.io/" rel="alternate" type="text/html" /><updated>2019-09-22T11:28:17+00:00</updated><id>https://oguzkonya.github.io/feed.xml</id><title type="html">oguzkonya</title><subtitle>Game Developer
</subtitle><author><name>Oguz Konya</name></author><entry><title type="html">Formatting Big Numbers: The aa Notation</title><link href="https://oguzkonya.github.io/formatting-big-numbers-aa-notation/" rel="alternate" type="text/html" title="Formatting Big Numbers: The aa Notation" /><published>2019-09-05T00:00:00+00:00</published><updated>2019-09-05T00:00:00+00:00</updated><id>https://oguzkonya.github.io/formatting-big-numbers-aa-notation</id><content type="html" xml:base="https://oguzkonya.github.io/formatting-big-numbers-aa-notation/">&lt;p&gt;If you are dealing with big numbers in your game, you might have encountered the issue of properly formatting them. Small numbers such as 1.000, 10.000 or even 100.000 are OK, but as you go larger, you’ll run out of space quickly. I mean, how can you fit &lt;strong&gt;1.000.000.000.000.000.000&lt;/strong&gt; in a button?&lt;/p&gt;

&lt;p&gt;But let’s say, you found a way. Let’s say you were able to put &lt;strong&gt;1.000.000.000.000.000.000&lt;/strong&gt; in a button properly and it looks good (I can’t imagine how, but for the sake of the argument let’s assume it is possible). However, you still have the UX problem of clarity. No one will be able to see this number and say “oh my gosh, I have one quintillion cookies!”. I am a mathematician and even I can’t read it without counting zeros first.&lt;/p&gt;

&lt;p&gt;There are two solutions to this problem and they both have pros and cons:&lt;/p&gt;

&lt;h2 id=&quot;scientific-notation&quot;&gt;Scientific notation&lt;/h2&gt;

&lt;p&gt;Mostly used by scientists and engineers, this notation is formatted as follows:&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;m x 10&lt;sup&gt;n&lt;/sup&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Where &lt;strong&gt;m&lt;/strong&gt; is a real number called &lt;em&gt;coefficient&lt;/em&gt;, and &lt;strong&gt;n&lt;/strong&gt; is an integer called &lt;em&gt;mantissa&lt;/em&gt;. In order to make this more concrete, let’s have a look at some examples:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Number&lt;/th&gt;
      &lt;th&gt;Scientific notation&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1.000&lt;/td&gt;
      &lt;td&gt;1x10&lt;sup&gt;3&lt;/sup&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5.000&lt;/td&gt;
      &lt;td&gt;5x10&lt;sup&gt;3&lt;/sup&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1.250.000&lt;/td&gt;
      &lt;td&gt;1,25x10&lt;sup&gt;6&lt;/sup&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1.254.678&lt;/td&gt;
      &lt;td&gt;1,254678x10&lt;sup&gt;6&lt;/sup&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1.500.000.000&lt;/td&gt;
      &lt;td&gt;1,5x10&lt;sup&gt;9&lt;/sup&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;The good thing about this notation is that you can format any number. Moreover, by using only 2 (or as much as you want) digits after the decimal point, you can make your numbers fit in a limited amount of space.&lt;/p&gt;

&lt;p&gt;The problem is that this notation is used by scientists and engineers (as I mentioned earlier), and it will not make any sense to most people. Even if it does, superscripts (I mean &lt;sup&gt;this&lt;/sup&gt;) would look really tiny on mobile screens and would cause minor UX problems.&lt;/p&gt;

&lt;h2 id=&quot;single-letter-notation&quot;&gt;Single letter notation&lt;/h2&gt;

&lt;p&gt;There is no science backing up this notation, it’s something purely linguistic: single letter after the number. This is the notation you use in your daily life.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Number&lt;/th&gt;
      &lt;th&gt;Single letter notation&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1.000&lt;/td&gt;
      &lt;td&gt;1k&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5.000&lt;/td&gt;
      &lt;td&gt;5k&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1.250.000&lt;/td&gt;
      &lt;td&gt;1,25m&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1.254.678&lt;/td&gt;
      &lt;td&gt;1,254678m&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1.500.000.000&lt;/td&gt;
      &lt;td&gt;1,5x10b&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Since it’s already used by everyone, this notation has the advantage of being accessible. Almost everyone can tell 1.25m means &lt;em&gt;one million two hundred fifty thousand&lt;/em&gt;. However, not many people would know that &lt;strong&gt;q&lt;/strong&gt; in &lt;strong&gt;1.25q&lt;/strong&gt; stands for &lt;em&gt;quadrillion&lt;/em&gt; and it becomes more of an issue as you go larger. See for yourself: quintillion, sextillion, septillion, octillion, nonillion. Do you see anything familiar? Probably no, because these units are not used in daily life unless you are a scientist or a mathematician. We need something more intuitive.&lt;/p&gt;

&lt;h2 id=&quot;the-aa-notation&quot;&gt;The “aa” notation&lt;/h2&gt;

&lt;p&gt;A better solution is the combination of the two: single letter notation up until (but not including) quadrillion and a two letter representation of scientific notation after trillion. It may sound confusing, but you’ll agree that it’s actually rather clear when you see it in action:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Number&lt;/th&gt;
      &lt;th&gt;Written&lt;/th&gt;
      &lt;th&gt;Scientific&lt;/th&gt;
      &lt;th&gt;Single letter&lt;/th&gt;
      &lt;th&gt;“aa”&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;one&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1.000&lt;/td&gt;
      &lt;td&gt;one thousand&lt;/td&gt;
      &lt;td&gt;1x103&lt;/td&gt;
      &lt;td&gt;1k&lt;/td&gt;
      &lt;td&gt;1k&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1.000.000&lt;/td&gt;
      &lt;td&gt;one million&lt;/td&gt;
      &lt;td&gt;1x106&lt;/td&gt;
      &lt;td&gt;1m&lt;/td&gt;
      &lt;td&gt;1m&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1.000.000.000&lt;/td&gt;
      &lt;td&gt;one billion&lt;/td&gt;
      &lt;td&gt;1x109&lt;/td&gt;
      &lt;td&gt;1b&lt;/td&gt;
      &lt;td&gt;1b&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1.000.000.000.000&lt;/td&gt;
      &lt;td&gt;one trillion&lt;/td&gt;
      &lt;td&gt;1x1012&lt;/td&gt;
      &lt;td&gt;1t&lt;/td&gt;
      &lt;td&gt;1t&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1.000.000.000.000.000&lt;/td&gt;
      &lt;td&gt;one quadrillion&lt;/td&gt;
      &lt;td&gt;1x1015&lt;/td&gt;
      &lt;td&gt;1q&lt;/td&gt;
      &lt;td&gt;1aa&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1.000.000.000.000.000.000&lt;/td&gt;
      &lt;td&gt;one quintillion&lt;/td&gt;
      &lt;td&gt;1x1018&lt;/td&gt;
      &lt;td&gt;1?&lt;/td&gt;
      &lt;td&gt;1ab&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;So, one quadrillion (10&lt;sup&gt;15&lt;/sup&gt;) will be represented with &lt;strong&gt;aa&lt;/strong&gt;. For every power of 1000 we’ll move the second letter up, so one quintillion (10&lt;sup&gt;18&lt;/sup&gt;) will be &lt;strong&gt;ab&lt;/strong&gt;, one sextillion will be &lt;strong&gt;ac&lt;/strong&gt;, and so on. After &lt;strong&gt;az&lt;/strong&gt;, we’ll move to &lt;strong&gt;ba&lt;/strong&gt;, &lt;strong&gt;bb&lt;/strong&gt;, &lt;strong&gt;bc&lt;/strong&gt; etc. This algorithm provides an incremental representation of big numbers and it does not require any scientific or mathematical knowledge. The algorithm for this notation is rather simple and it’s really easy to implement in any programming language.&lt;/p&gt;

&lt;p&gt;First we need to represent the number in a slightly modified scientific notation. Since we change the unit for every power of 1000 we’ll convert our number to this: m x 1000&lt;sup&gt;n &lt;/sup&gt;. In order to find m and n, all we have to do is revert the formula and apply it:&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;n = (int) log(value, 1000);
m = value / pow(1000, n);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If n is less than 5 (i.e the number is less than 1x10&lt;sup&gt;15&lt;/sup&gt;), we will use the single letter notation (K, M, B, or T). If it is greater than or equal to 5, we’ll convert this number to “aa” notation. So 5 (10&lt;sup&gt;15&lt;/sup&gt;) will be &lt;strong&gt;aa&lt;/strong&gt;, 6 (10&lt;sup&gt;18&lt;/sup&gt;) will be &lt;strong&gt;ab&lt;/strong&gt;, 7 (10&lt;sup&gt;21&lt;/sup&gt;) will be &lt;strong&gt;ac&lt;/strong&gt; and so on. Since there are 26 letters in English language, converting n to a two letter representation would require one modulo and one division operations:&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;secondUnit = n % 26; 
firstUnit = n / 26; 
unit = firstUnit.toChar() + secondUnit.toChar();&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That’s all there is to it. And here is the implementation in C#:&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;public static class CalcUtils
{
    private static readonly int charA = Convert.ToInt32(&amp;#39;a&amp;#39;);

    private static readonly Dictionary&amp;lt;int, string&amp;gt; units = new Dictionary&amp;lt;int, string&amp;gt;
    {
        {0, &amp;quot;&amp;quot;},
        {1, &amp;quot;K&amp;quot;},
        {2, &amp;quot;M&amp;quot;},
        {3, &amp;quot;B&amp;quot;},
        {4, &amp;quot;T&amp;quot;}
    };

    public static string FormatNumber(double value)
    {
        if (value &amp;lt; 1d)
        {
            return &amp;quot;0&amp;quot;;
        }

        var n = (int) Math.Log(value, 1000);
        var m = value / Math.Pow(1000, n);
        var unit = &amp;quot;&amp;quot;;

        if (n &amp;lt; units.Count)
        {
            unit = units[n];
        }
        else
        {
            var unitInt = n - units.Count;
            var secondUnit = unitInt % 26;
            var firstUnit = unitInt / 26;
            unit = Convert.ToChar(firstUnit + charA).ToString() + Convert.ToChar(secondUnit + charA).ToString();
        }

        // Math.Floor(m * 100) / 100) fixes rounding errors
        return (Math.Floor(m * 100) / 100).ToString(&amp;quot;0.##&amp;quot;) + unit;
    }
}&lt;/code&gt;&lt;/pre&gt;</content><author><name>Oguz Konya</name></author><summary type="html">If you are dealing with big numbers in your game, you might have encountered the issue of properly formatting them. Small numbers such as 1.000, 10.000 or even 100.000 are OK, but as you go larger, you’ll run out of space quickly. I mean, how can you fit 1.000.000.000.000.000.000 in a button?</summary></entry><entry><title type="html">Serializing a Node Based Editor in Unity</title><link href="https://oguzkonya.github.io/serializing-node-based-editor-unity/" rel="alternate" type="text/html" title="Serializing a Node Based Editor in Unity" /><published>2019-08-29T00:00:00+00:00</published><updated>2019-08-29T00:00:00+00:00</updated><id>https://oguzkonya.github.io/serializing-node-based-editor-unity</id><content type="html" xml:base="https://oguzkonya.github.io/serializing-node-based-editor-unity/">&lt;p&gt;I actually don’t get a lot of feedback on my posts, but one post stood out: &lt;a href=&quot;/creating-node-based-editor-unity/&quot;&gt;Creating a Node Based Editor in Unity&lt;/a&gt;. Some people asked for a more advanced version and some asked how they can save and load data to the editor. I can make an advanced version, but it probably wouldn’t cover all usage cases. On the other hand, serializing (and deserializing) a node list is a more common problem. Although I addressed some issues in &lt;a href=&quot;/xml-serialization-and-deserialization-in-unity/&quot;&gt;XML Serialization in Unity&lt;/a&gt; post, I would like to complete the node based editor by adding save and load features in this post.&lt;/p&gt;

&lt;p&gt;So, in this post we’ll have a look at those two posts, merge them together and fix some issues. We might even end up revisiting &lt;a href=&quot;/creating-clone-unitys-console-window/&quot;&gt;Creating a Clone of Unity’s Console Window&lt;/a&gt;. After this tutorial, you’ll have a node based editor which can restore its last state after it is closed.&lt;/p&gt;

&lt;h3 id=&quot;revisiting-the-node-based-editor&quot;&gt;Revisiting the Node Based Editor&lt;/h3&gt;

&lt;p&gt;Well, it’s kind of obvious, but we need a node based editor in order to serialize it. We’ll use the code from &lt;a href=&quot;/creating-node-based-editor-unity/&quot;&gt;this&lt;/a&gt; post, so if you haven’t already, go ahead and check it out now. It’s pretty straightforward, but we’ll have to modify it in order to properly serialize the nodes.&lt;/p&gt;

&lt;div class=&quot;img-wrapper&quot;&gt;
    
    &lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;/assets/img/node-based-editor.gif&quot;&gt;
    
        &lt;img src=&quot;/assets/img/node-based-editor.gif&quot; class=&quot;center&quot; alt=&quot;Node based editor&quot; width=&quot;480px&quot; /&gt;
    
    &lt;/a&gt;
    
    &lt;em&gt;The node based editor we created previously&lt;/em&gt;
&lt;/div&gt;

&lt;h3 id=&quot;revisiting-xml-serialization&quot;&gt;Revisiting XML Serialization&lt;/h3&gt;

&lt;p&gt;There are a number of serialization options, such as JSON or Unity’s own serialization system. However, since we already covered XML serialization previously, why not use it? We’ll use the &lt;code class=&quot;highlighter-rouge&quot;&gt;XMLOp&lt;/code&gt; class and some of the XML attributes from &lt;a href=&quot;/xml-serialization-and-deserialization-in-unity/&quot;&gt;this&lt;/a&gt; post.&lt;/p&gt;

&lt;h3 id=&quot;revisiting-console-window-clone&quot;&gt;Revisiting Console Window Clone&lt;/h3&gt;
&lt;p&gt;This post is not that relevant to our matter at hand, but the node editor window lacks buttons for saving and loading. It would be nice to stick with Unity’s standards, so I’ll copy the menu bar from this window clone. It is easy to implement and nice to look at.&lt;/p&gt;

&lt;div class=&quot;img-wrapper&quot;&gt;
    
    &lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;/assets/img/unity-console-window.png&quot;&gt;
    
        &lt;img src=&quot;/assets/img/unity-console-window.png&quot; class=&quot;center&quot; alt=&quot;Unity's console window&quot; width=&quot;480px&quot; /&gt;
    
    &lt;/a&gt;
    
    &lt;em&gt;We'll copy the part that you see in area 1&lt;/em&gt;
&lt;/div&gt;

&lt;h3 id=&quot;adding-a-menu-bar&quot;&gt;Adding a Menu Bar&lt;/h3&gt;

&lt;p&gt;We’ll start with adding a menu bar, and we’ll copy it from the console window clone:&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;    private float menuBarHeight = 20f;
    private Rect menuBar;&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;    private void OnGUI()
    {
        DrawGrid(20, 0.2f, Color.gray);
        DrawGrid(100, 0.4f, Color.gray);
        DrawMenuBar();

        DrawNodes();
        DrawConnections();

        DrawConnectionLine(Event.current);

        ProcessNodeEvents(Event.current);
        ProcessEvents(Event.current);

        if (GUI.changed) Repaint();
    }

    private void DrawMenuBar()
    {
        menuBar = new Rect(0, 0, position.width, menuBarHeight);

        GUILayout.BeginArea(menuBar, EditorStyles.toolbar);
        GUILayout.BeginHorizontal();

        GUILayout.Button(new GUIContent(&amp;quot;Save&amp;quot;), EditorStyles.toolbarButton, GUILayout.Width(35));
        GUILayout.Space(5);
        GUILayout.Button(new GUIContent(&amp;quot;Load&amp;quot;), EditorStyles.toolbarButton, GUILayout.Width(35));

        GUILayout.EndHorizontal();
        GUILayout.EndArea();
    }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On line 56, we call &lt;code class=&quot;highlighter-rouge&quot;&gt;DrawMenuBar()&lt;/code&gt; method and between lines 69-82 we create the menu bar. The console window clone had a button and 6 toggles, but since we are only serializing and deserializing, we need no more than two buttons. Keep in mind that the editor GUI system has a draw order and it &lt;strong&gt;draws elements from back to front in the order you call them&lt;/strong&gt;. That’s why we are drawing the menu bar after drawing the grid. Otherwise the grid would have been drawn over the menu bar.&lt;/p&gt;

&lt;div class=&quot;img-wrapper&quot;&gt;
    
    &lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;/assets/img/grid-over-menu-bar.png&quot;&gt;
    
        &lt;img src=&quot;/assets/img/grid-over-menu-bar.png&quot; class=&quot;center&quot; alt=&quot;Grid over menu bar&quot; width=&quot;480px&quot; /&gt;
    
    &lt;/a&gt;
    
    &lt;em&gt;DrawMenuBar() is called before DrawGrid(), hence the ugly grid over the menu bar.&lt;/em&gt;
&lt;/div&gt;

&lt;p&gt;Currently, save and load buttons do nothing, but we’ll get to that.&lt;/p&gt;

&lt;h3 id=&quot;serialization&quot;&gt;Serialization&lt;/h3&gt;

&lt;p&gt;Next up, we need to prepare our classes (&lt;code class=&quot;highlighter-rouge&quot;&gt;Node&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Connection&lt;/code&gt;) for serialization. Let’s remember the two important key points about XML serializing:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;XML serializer can only serialize public fields.&lt;/li&gt;
  &lt;li&gt;Class to be serialized should have a parameterless constructor.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Rule number 1 doesn’t cause that many problems (it still causes some but we’ll get to that), but rule number 2 is problematic. Both of our classes have constructors &lt;strong&gt;with&lt;/strong&gt; parameters. Let’s fix that first:&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;    public Node() { }
    
    public Node(Vector2 position, float width, float height, GUIStyle nodeStyle, GUIStyle selectedStyle, GUIStyle inPointStyle, GUIStyle outPointStyle, Action&amp;lt;ConnectionPoint&amp;gt; OnClickInPoint, Action&amp;lt;ConnectionPoint&amp;gt; OnClickOutPoint, Action&amp;lt;Node&amp;gt; OnClickRemoveNode)
    {
        rect = new Rect(position.x, position.y, width, height);
        style = nodeStyle;
        inPoint = new ConnectionPoint(this, ConnectionPointType.In, inPointStyle, OnClickInPoint);
        outPoint = new ConnectionPoint(this, ConnectionPointType.Out, outPointStyle, OnClickOutPoint);
        defaultNodeStyle = nodeStyle;
        selectedNodeStyle = selectedStyle;
        OnRemoveNode = OnClickRemoveNode;
    }&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;    public Connection() { }
    
    public Connection(ConnectionPoint inPoint, ConnectionPoint outPoint, Action&amp;lt;Connection&amp;gt; OnClickRemoveConnection)
    {
        this.inPoint = inPoint;
        this.outPoint = outPoint;
        this.OnClickRemoveConnection = OnClickRemoveConnection;
    }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we are going to &lt;strong&gt;ignore&lt;/strong&gt; the properties that can’t be serialized or don’t need to be serialized. For example, in &lt;code class=&quot;highlighter-rouge&quot;&gt;Node&lt;/code&gt; class, &lt;code class=&quot;highlighter-rouge&quot;&gt;GUIStyle&lt;/code&gt;s can be left out of serialization, because they are already provided by the editor itself. We don’t need &lt;code class=&quot;highlighter-rouge&quot;&gt;isDragged&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;isSelected&lt;/code&gt; either. Actually, Node class has only one property that needs to be serialized: the &lt;code class=&quot;highlighter-rouge&quot;&gt;rect&lt;/code&gt;. Let’s see how &lt;code class=&quot;highlighter-rouge&quot;&gt;Node&lt;/code&gt; class looks like after properly &lt;strong&gt;ignoring&lt;/strong&gt; unnecessary and unserializable properties:&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;public class Node
{
	public Rect rect;

	[XmlIgnore] public string title;
	[XmlIgnore] public bool isDragged;
	[XmlIgnore] public bool isSelected;

	[XmlIgnore] public ConnectionPoint inPoint;
	[XmlIgnore] public ConnectionPoint outPoint;

	[XmlIgnore] public GUIStyle style;
	[XmlIgnore] public GUIStyle defaultNodeStyle;
	[XmlIgnore] public GUIStyle selectedNodeStyle;

	[XmlIgnore] public Action&amp;lt;Node&amp;gt; OnRemoveNode;

	public Node()
	{
	}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Node&lt;/code&gt; class is ready to be serialized at this point. So, let’s serialize nodes!&lt;/p&gt;

&lt;h3 id=&quot;saving-nodes&quot;&gt;Saving Nodes&lt;/h3&gt;

&lt;p&gt;Remember the save button which did nothing at all? Well, it should at least save nodes, since they are now serializable. The method for saving nodes is really simple:&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;    private void Save()
    {
        XMLOp.Serialize(nodes, &amp;quot;Assets/Resources/nodes.xml&amp;quot;);
    }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And we are going to call that method when the user clicks Save button:&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;    private void DrawMenuBar()
    {
        menuBar = new Rect(0, 0, position.width, menuBarHeight);

        GUILayout.BeginArea(menuBar, EditorStyles.toolbar);
        GUILayout.BeginHorizontal();

        if (GUILayout.Button(new GUIContent(&amp;quot;Save&amp;quot;), EditorStyles.toolbarButton, GUILayout.Width(35)))
        {
            Save();
        }
        
        GUILayout.Space(5);
        GUILayout.Button(new GUIContent(&amp;quot;Load&amp;quot;), EditorStyles.toolbarButton, GUILayout.Width(35));

        GUILayout.EndHorizontal();
        GUILayout.EndArea();
    }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, open up your Node Based Editor, place a couple of nodes, and then hit Save (you must have a Resources folder under Assets before doing that). Unity will create a file called &lt;code class=&quot;highlighter-rouge&quot;&gt;nodes.xml&lt;/code&gt; in Resources, if you can’t see it, simply right-click on Resources and then click Reimport. Contents of the nodes.xml file should be something like this:&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;ArrayOfNode xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xmlns:xsd=&amp;quot;http://www.w3.org/2001/XMLSchema&amp;quot;&amp;gt;
  &amp;lt;Node&amp;gt;
    &amp;lt;rect&amp;gt;
      &amp;lt;x&amp;gt;166&amp;lt;/x&amp;gt;
      &amp;lt;y&amp;gt;183&amp;lt;/y&amp;gt;
      &amp;lt;position&amp;gt;
        &amp;lt;x&amp;gt;166&amp;lt;/x&amp;gt;
        &amp;lt;y&amp;gt;183&amp;lt;/y&amp;gt;
      &amp;lt;/position&amp;gt;
      &amp;lt;center&amp;gt;
        &amp;lt;x&amp;gt;266&amp;lt;/x&amp;gt;
        &amp;lt;y&amp;gt;208&amp;lt;/y&amp;gt;
      &amp;lt;/center&amp;gt;
      &amp;lt;min&amp;gt;
        &amp;lt;x&amp;gt;166&amp;lt;/x&amp;gt;
        &amp;lt;y&amp;gt;183&amp;lt;/y&amp;gt;
      &amp;lt;/min&amp;gt;
      &amp;lt;max&amp;gt;
        &amp;lt;x&amp;gt;366&amp;lt;/x&amp;gt;
        &amp;lt;y&amp;gt;233&amp;lt;/y&amp;gt;
      &amp;lt;/max&amp;gt;
      &amp;lt;width&amp;gt;200&amp;lt;/width&amp;gt;
      &amp;lt;height&amp;gt;50&amp;lt;/height&amp;gt;
      &amp;lt;size&amp;gt;
        &amp;lt;x&amp;gt;200&amp;lt;/x&amp;gt;
        &amp;lt;y&amp;gt;50&amp;lt;/y&amp;gt;
      &amp;lt;/size&amp;gt;
      &amp;lt;xMin&amp;gt;166&amp;lt;/xMin&amp;gt;
      &amp;lt;yMin&amp;gt;183&amp;lt;/yMin&amp;gt;
      &amp;lt;xMax&amp;gt;366&amp;lt;/xMax&amp;gt;
      &amp;lt;yMax&amp;gt;233&amp;lt;/yMax&amp;gt;
    &amp;lt;/rect&amp;gt;
  &amp;lt;/Node&amp;gt;
  &amp;lt;Node&amp;gt;
    &amp;lt;rect&amp;gt;
      &amp;lt;x&amp;gt;345&amp;lt;/x&amp;gt;
      &amp;lt;y&amp;gt;345&amp;lt;/y&amp;gt;
      &amp;lt;position&amp;gt;
        &amp;lt;x&amp;gt;345&amp;lt;/x&amp;gt;
        &amp;lt;y&amp;gt;345&amp;lt;/y&amp;gt;
      &amp;lt;/position&amp;gt;
      &amp;lt;center&amp;gt;
        &amp;lt;x&amp;gt;445&amp;lt;/x&amp;gt;
        &amp;lt;y&amp;gt;370&amp;lt;/y&amp;gt;
      &amp;lt;/center&amp;gt;
      &amp;lt;min&amp;gt;
        &amp;lt;x&amp;gt;345&amp;lt;/x&amp;gt;
        &amp;lt;y&amp;gt;345&amp;lt;/y&amp;gt;
      &amp;lt;/min&amp;gt;
      &amp;lt;max&amp;gt;
        &amp;lt;x&amp;gt;545&amp;lt;/x&amp;gt;
        &amp;lt;y&amp;gt;395&amp;lt;/y&amp;gt;
      &amp;lt;/max&amp;gt;
      &amp;lt;width&amp;gt;200&amp;lt;/width&amp;gt;
      &amp;lt;height&amp;gt;50&amp;lt;/height&amp;gt;
      &amp;lt;size&amp;gt;
        &amp;lt;x&amp;gt;200&amp;lt;/x&amp;gt;
        &amp;lt;y&amp;gt;50&amp;lt;/y&amp;gt;
      &amp;lt;/size&amp;gt;
      &amp;lt;xMin&amp;gt;345&amp;lt;/xMin&amp;gt;
      &amp;lt;yMin&amp;gt;345&amp;lt;/yMin&amp;gt;
      &amp;lt;xMax&amp;gt;545&amp;lt;/xMax&amp;gt;
      &amp;lt;yMax&amp;gt;395&amp;lt;/yMax&amp;gt;
    &amp;lt;/rect&amp;gt;
  &amp;lt;/Node&amp;gt;
&amp;lt;/ArrayOfNode&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, our nodes can be serialized now and if we can serialize &lt;code class=&quot;highlighter-rouge&quot;&gt;Connection&lt;/code&gt;s, our node editor will be completely serializable. Let’s get on with it then.&lt;/p&gt;

&lt;h3 id=&quot;serializing-connections&quot;&gt;Serializing Connections&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Connection&lt;/code&gt; class has only 2 properties that can be serialized: &lt;code class=&quot;highlighter-rouge&quot;&gt;inPoint (ConnectionPoint)&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;outPoint (ConnectionPoint)&lt;/code&gt;. However, serializing these two properties would be meaningless, because objects do not keep references to other objects after deserialization. Which means, if we deserialize a connection, it would create two connection points and connect them, but those connection points wouldn’t belong to the nodes it used to connect (see the figure below).&lt;/p&gt;

&lt;div class=&quot;img-wrapper&quot;&gt;
    
    &lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;/assets/img/serialization.png&quot;&gt;
    
        &lt;img src=&quot;/assets/img/serialization.png&quot; class=&quot;center&quot; alt=&quot;Broken connections&quot; width=&quot;480px&quot; /&gt;
    
    &lt;/a&gt;
    
    &lt;em&gt;Serialization breaks connections and deserializing doesn't fix that.&lt;/em&gt;
&lt;/div&gt;

&lt;p&gt;In order to solve this issue, we need some kind of an identifier for a connection point, i.e a unique ID, so that after deserializing, we can look for those connection points by their IDs and give reference to actual objects to restore connections.&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;public class ConnectionPoint
{
    public string id;
    
    [XmlIgnore] public Rect rect;

    [XmlIgnore] public ConnectionPointType type;

    [XmlIgnore] public Node node;

    [XmlIgnore] public GUIStyle style;

    [XmlIgnore] public Action&amp;lt;ConnectionPoint&amp;gt; OnClickConnectionPoint;

    public ConnectionPoint() { }
    
    public ConnectionPoint(Node node, ConnectionPointType type, GUIStyle style, Action&amp;lt;ConnectionPoint&amp;gt; OnClickConnectionPoint, string id = null)
    {
        this.node = node;
        this.type = type;
        this.style = style;
        this.OnClickConnectionPoint = OnClickConnectionPoint;
        rect = new Rect(0, 0, 10f, 20f);

        this.id = id ?? Guid.NewGuid().ToString();
    }&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;public class Connection
{
    public ConnectionPoint inPoint;
    public ConnectionPoint outPoint;
    [XmlIgnore] public Action&amp;lt;Connection&amp;gt; OnClickRemoveConnection;&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;public class Node
{
	public Rect rect;

	[XmlIgnore] public string title;
	[XmlIgnore] public bool isDragged;
	[XmlIgnore] public bool isSelected;

	public ConnectionPoint inPoint;
	public ConnectionPoint outPoint;

	[XmlIgnore] public GUIStyle style;
	[XmlIgnore] public GUIStyle defaultNodeStyle;
	[XmlIgnore] public GUIStyle selectedNodeStyle;

	[XmlIgnore] public Action&amp;lt;Node&amp;gt; OnRemoveNode;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, we need to update our &lt;code class=&quot;highlighter-rouge&quot;&gt;Save&lt;/code&gt; method to include connections as well:&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;    private void Save()
    {
        XMLOp.Serialize(nodes, &amp;quot;Assets/Resources/nodes.xml&amp;quot;);
        XMLOp.Serialize(connections, &amp;quot;Assets/Resources/connections.xml&amp;quot;);
    }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This concludes the serialization (and frankly, the hard) part. Now we have an XML representation of the current state of our node based editor. All we have to do is convert it back.&lt;/p&gt;

&lt;h3 id=&quot;deserializing&quot;&gt;Deserializing&lt;/h3&gt;

&lt;p&gt;First things first: the Load button should be functional.&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;    private void DrawMenuBar()
    {
        menuBar = new Rect(0, 0, position.width, menuBarHeight);

        GUILayout.BeginArea(menuBar, EditorStyles.toolbar);
        GUILayout.BeginHorizontal();

        if (GUILayout.Button(new GUIContent(&amp;quot;Save&amp;quot;), EditorStyles.toolbarButton, GUILayout.Width(35)))
        {
            Save();
        }
        
        GUILayout.Space(5);

        if (GUILayout.Button(new GUIContent(&amp;quot;Load&amp;quot;), EditorStyles.toolbarButton, GUILayout.Width(35)))
        {
            Load();
        }

        GUILayout.EndHorizontal();
        GUILayout.EndArea();
    }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are going to deserialize the contents of the XML files in &lt;code class=&quot;highlighter-rouge&quot;&gt;Load()&lt;/code&gt; method, create nodes and connections and assign them to their respective properties. Deserializing the XML files is a pretty straightforward process; all we have to do is call &lt;code class=&quot;highlighter-rouge&quot;&gt;XMLOp.Deserialize&amp;lt;T&amp;gt;(string)&lt;/code&gt;:&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;    private void Load()
    {
        var nodesDeserialized = XMLOp.Deserialize&amp;lt;List&amp;lt;Node&amp;gt;&amp;gt;(&amp;quot;Assets/Resources/nodes.xml&amp;quot;);
        var connectionsDeserialized = XMLOp.Deserialize&amp;lt;List&amp;lt;Connection&amp;gt;&amp;gt;(&amp;quot;Assets/Resources/connections.xml&amp;quot;);

        nodes = new List&amp;lt;Node&amp;gt;();
        connections = new List&amp;lt;Connection&amp;gt;();
    }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, deserializing the XML files alone is not enough to restore our editor to its last state, because as you can see in the figure above, we broke the relation between the nodes and connections while serializing and we need to reconnect them. This reconnection process requires finding nodes by IDs and creating a connection between them. This is why we added unique IDs to our &lt;code class=&quot;highlighter-rouge&quot;&gt;ConnectionPoint&lt;/code&gt; class. We need to recreate the &lt;code class=&quot;highlighter-rouge&quot;&gt;ConnectionPoint&lt;/code&gt;s with those IDs, so we are going to add another constructor to Node class:&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;    public Node(Vector2 position, float width, float height, GUIStyle nodeStyle, GUIStyle selectedStyle, GUIStyle inPointStyle, GUIStyle outPointStyle, Action&amp;lt;ConnectionPoint&amp;gt; OnClickInPoint,
		Action&amp;lt;ConnectionPoint&amp;gt; OnClickOutPoint, Action&amp;lt;Node&amp;gt; OnClickRemoveNode, string inPointID, string outPointID)
	{
		rect = new Rect(position.x, position.y, width, height);
		style = nodeStyle;
		inPoint = new ConnectionPoint(this, ConnectionPointType.In, inPointStyle, OnClickInPoint, inPointID);
		outPoint = new ConnectionPoint(this, ConnectionPointType.Out, outPointStyle, OnClickOutPoint, outPointID);
		defaultNodeStyle = nodeStyle;
		selectedNodeStyle = selectedStyle;
		OnRemoveNode = OnClickRemoveNode;
	}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a new constructor, and it will create a &lt;code class=&quot;highlighter-rouge&quot;&gt;Node&lt;/code&gt; with two &lt;code class=&quot;highlighter-rouge&quot;&gt;ConnectionPoints&lt;/code&gt; with given (instead of generated) IDs. Now we are going to create new nodes based on deserialized nodes:&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;    private void Load()
    {
        var nodesDeserialized = XMLOp.Deserialize&amp;lt;List&amp;lt;Node&amp;gt;&amp;gt;(&amp;quot;Assets/Resources/nodes.xml&amp;quot;);
        var connectionsDeserialized = XMLOp.Deserialize&amp;lt;List&amp;lt;Connection&amp;gt;&amp;gt;(&amp;quot;Assets/Resources/connections.xml&amp;quot;);

        nodes = new List&amp;lt;Node&amp;gt;();
        connections = new List&amp;lt;Connection&amp;gt;();

        foreach (var nodeDeserialized in nodesDeserialized)
        {
            nodes.Add(new Node(
                nodeDeserialized.rect.position, 
                nodeDeserialized.rect.width, 
                nodeDeserialized.rect.height, 
                nodeStyle, 
                selectedNodeStyle, 
                inPointStyle, 
                outPointStyle, 
                OnClickInPoint, 
                OnClickOutPoint, 
                OnClickRemoveNode,
                nodeDeserialized.inPoint.id,
                nodeDeserialized.outPoint.id
                )
            );
        }
    }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go ahead and try it. Create a couple of nodes, save it, close the editor, open it again and hit the Load button. You’ll see that your nodes return back to their positions. Let’s deserialize connections and finalize our node based editor:&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;    private void Load()
    {
        var nodesDeserialized = XMLOp.Deserialize&amp;lt;List&amp;lt;Node&amp;gt;&amp;gt;(&amp;quot;Assets/Resources/nodes.xml&amp;quot;);
        var connectionsDeserialized = XMLOp.Deserialize&amp;lt;List&amp;lt;Connection&amp;gt;&amp;gt;(&amp;quot;Assets/Resources/connections.xml&amp;quot;);

        nodes = new List&amp;lt;Node&amp;gt;();
        connections = new List&amp;lt;Connection&amp;gt;();

        foreach (var nodeDeserialized in nodesDeserialized)
        {
            nodes.Add(new Node(
                nodeDeserialized.rect.position, 
                nodeDeserialized.rect.width, 
                nodeDeserialized.rect.height, 
                nodeStyle, 
                selectedNodeStyle, 
                inPointStyle, 
                outPointStyle, 
                OnClickInPoint, 
                OnClickOutPoint, 
                OnClickRemoveNode,
                nodeDeserialized.inPoint.id,
                nodeDeserialized.outPoint.id
                )
            );
        }

        foreach (var connectionDeserialized in connectionsDeserialized)
        {
            var inPoint = nodes.First(n =&amp;gt; n.inPoint.id == connectionDeserialized.inPoint.id).inPoint;
            var outPoint = nodes.First(n =&amp;gt; n.outPoint.id == connectionDeserialized.outPoint.id).outPoint;
            connections.Add(new Connection(inPoint, outPoint, OnClickRemoveConnection));
        }
    }&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;last-words&quot;&gt;Last Words&lt;/h3&gt;

&lt;p&gt;This concludes our tutorial on serializing a node based editor. You now have a fully functioning node based editor with save and load features. If you have any questions or feedback, leave a comment.&lt;/p&gt;

&lt;p&gt;As always, here are the scripts in full, below. Until next time.&lt;/p&gt;</content><author><name>Oguz Konya</name></author><summary type="html">I actually don’t get a lot of feedback on my posts, but one post stood out: Creating a Node Based Editor in Unity. Some people asked for a more advanced version and some asked how they can save and load data to the editor. I can make an advanced version, but it probably wouldn’t cover all usage cases. On the other hand, serializing (and deserializing) a node list is a more common problem. Although I addressed some issues in XML Serialization in Unity post, I would like to complete the node based editor by adding save and load features in this post.</summary></entry><entry><title type="html">XML Serialization in Unity</title><link href="https://oguzkonya.github.io/xml-serialization-and-deserialization-in-unity/" rel="alternate" type="text/html" title="XML Serialization in Unity" /><published>2019-08-22T00:00:00+00:00</published><updated>2019-08-22T00:00:00+00:00</updated><id>https://oguzkonya.github.io/xml-serialization-and-deserialization-in-unity</id><content type="html" xml:base="https://oguzkonya.github.io/xml-serialization-and-deserialization-in-unity/">&lt;p&gt;Unity stores contents of a scene in a custom YAML file called a &lt;strong&gt;Unity scene file&lt;/strong&gt;. While this is convenient for levels which are designed in Unity’s scene editor, it is not very useful for levels which are built at runtime. Moreover, it is not possible to store game related data in scene files, such as properties of weapons, cars, NPCs, etc. (actually, it is possible, but not feasible). Even though there are a few solutions for that kind of data storage in Unity, such as JSON, or SQL, the easiest of them to implement is XML. In this post, I will show you how to store your game data in XML files and read them at runtime.&lt;/p&gt;

&lt;p&gt;To be able to save data in XML files, first we need to be able to convert objects into XML format and then convert XML format back into objects. This process is called &lt;abbr title=&quot;Converting objects into a form (such as JSON, or XML) that can be easily transported.&quot;&gt;serialization&lt;/abbr&gt; and &lt;abbr title=&quot;Creating objects from transport formats such as JSON, or XML.&quot;&gt;deserialization&lt;/abbr&gt;. C# already has great tools for XML &lt;abbr title=&quot;Converting objects into a form (such as JSON, or XML) that can be easily transported.&quot;&gt;serialization&lt;/abbr&gt;, and we will build upon them to create XML serializer we need.&lt;/p&gt;

&lt;p&gt;First, let’s create a sample class to start serializing:&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;public class Hero
{
    public string name;

    public bool isBoss;

    public int hitPoints;

    public float baseDamage;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a very basic version of a &lt;code class=&quot;highlighter-rouge&quot;&gt;Hero&lt;/code&gt; class that you might find yourself creating for your game. You may think that it is &lt;em&gt;too&lt;/em&gt; basic, but don’t worry, we will be adding features as we move on. However, before moving on, you should know two important key points about XML serializing:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;XML serializer can only serialize public fields.&lt;/li&gt;
  &lt;li&gt;Class to be serialized should have a parameterless constructor.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In our case, &lt;code class=&quot;highlighter-rouge&quot;&gt;Hero&lt;/code&gt; class already has nothing but public fields and since there isn’t any kind of constructor, it implicitly has a parameterless default constructor.&lt;/p&gt;

&lt;p&gt;Let’s say we want this class to output an XML file just like the following:&lt;/p&gt;
&lt;pre class=&quot;language-xml  line-numbers &quot;&gt;&lt;code&gt;&amp;lt;Hero&amp;gt;
    &amp;lt;name&amp;gt;&amp;lt;/name&amp;gt;
    &amp;lt;isBoss&amp;gt;&amp;lt;/isBoss&amp;gt;
    &amp;lt;hitPoints&amp;gt;&amp;lt;/hitPoints&amp;gt;
    &amp;lt;baseDamage&amp;gt;&amp;lt;/baseDamage&amp;gt;
&amp;lt;/Hero&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Generally, producing an XML file in a certain format requires some modification to target class. But, in our case we are not looking for a specific format. All our fields we want to serialize are public and there is a default constructor, therefore, we can start creating the XML file:&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;using UnityEngine;
using System.Xml.Serialization;
using System.IO;

public class XMLSerializer : MonoBehaviour 
{
    private void Start() 
    {
        Hero knight = new Hero();
        knight.name = &amp;quot;Knight of Solamnia&amp;quot;;
        knight.isBoss = true;
        knight.hitPoints = 100;
        knight.baseDamage = 50f;

        XmlSerializer serializer = new XmlSerializer(typeof(Hero));
        StreamWriter writer = new StreamWriter(&amp;quot;hero.xml&amp;quot;);
        serializer.Serialize(writer.BaseStream, knight);
        writer.Close();
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let’s have a look at this code line by line:&lt;/p&gt;

&lt;p&gt;On &lt;strong&gt;Line 9-13&lt;/strong&gt;, we create a new &lt;code class=&quot;highlighter-rouge&quot;&gt;Hero&lt;/code&gt; and assign its &lt;abbr title=&quot;A method to associate declarative information with the code&quot;&gt;attributes&lt;/abbr&gt;.&lt;/p&gt;

&lt;p&gt;On &lt;strong&gt;Line 15&lt;/strong&gt;, we create an &lt;code class=&quot;highlighter-rouge&quot;&gt;XmlSerializer&lt;/code&gt; instance with type of &lt;code class=&quot;highlighter-rouge&quot;&gt;Hero&lt;/code&gt;, since it is the type of the class we are serializing. This &lt;code class=&quot;highlighter-rouge&quot;&gt;XmlSerializer&lt;/code&gt; is a C# class and it can be found under &lt;code class=&quot;highlighter-rouge&quot;&gt;System.Xml.Serialization&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;On &lt;strong&gt;Line 16&lt;/strong&gt;, we create a &lt;code class=&quot;highlighter-rouge&quot;&gt;StreamWriter&lt;/code&gt; instance which would create the XML file itself and do the actual writing. &lt;code class=&quot;highlighter-rouge&quot;&gt;StreamWriter&lt;/code&gt; is also a C# class and it can be found under &lt;code class=&quot;highlighter-rouge&quot;&gt;System.IO&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;On &lt;strong&gt;Line 17&lt;/strong&gt;, we tell the &lt;code class=&quot;highlighter-rouge&quot;&gt;XmlSerializer&lt;/code&gt; to serialize knight (our &lt;code class=&quot;highlighter-rouge&quot;&gt;Hero&lt;/code&gt;), and send it to a stream.&lt;/p&gt;

&lt;p&gt;And finally, on &lt;strong&gt;Line 18&lt;/strong&gt;, we tell writer to close streaming (i.e stop reading input and create the file).&lt;/p&gt;

&lt;p&gt;When you drag&amp;amp;drop this code on an empty game object in Unity and run it, you will see that a file named &lt;code class=&quot;highlighter-rouge&quot;&gt;hero.xml&lt;/code&gt; is created in your Unity project folder and its contents hold Hero data:&lt;/p&gt;

&lt;pre class=&quot;language-xml  line-numbers &quot;&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;Hero xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xmlns:xsd=&amp;quot;http://www.w3.org/2001/XMLSchema&amp;quot;&amp;gt;
    &amp;lt;name&amp;gt;Knight of Solamnia&amp;lt;/name&amp;gt;
    &amp;lt;isBoss&amp;gt;true&amp;lt;/isBoss&amp;gt;
    &amp;lt;hitPoints&amp;gt;100&amp;lt;/hitPoints&amp;gt;
    &amp;lt;baseDamage&amp;gt;50&amp;lt;/baseDamage&amp;gt;
&amp;lt;/Hero&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, creating an XML file required no more than a few lines of code. But, what if we want to have different tag names in the XML file? Or, to use XML &lt;abbr title=&quot;A method to associate declarative information with the code&quot;&gt;attributes&lt;/abbr&gt; instead of XML elements to store data? Or, to use arrays in our class? To achieve these, we need to modify our base class by adding some XML &lt;abbr title=&quot;A method to associate declarative information with the code&quot;&gt;attributes&lt;/abbr&gt; to our fields. But first, we should change something in our code. I like my code well organized and I favor OOP’s single responsibility principle, so I will move XML &lt;abbr title=&quot;Converting objects into a form (such as JSON, or XML) that can be easily transported.&quot;&gt;serialization&lt;/abbr&gt; part into its own class. This way, we will be able to serialize any type of object with a single line of code:&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;using System.IO;
using System.Xml.Serialization;

public class XMLOp
{
    public static void Serialize(object item, string path)
    {
        XmlSerializer serializer = new XmlSerializer(item.GetType());
        StreamWriter writer = new StreamWriter(path);
        serializer.Serialize(writer.BaseStream, item);
        writer.Close();
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now our &lt;code class=&quot;highlighter-rouge&quot;&gt;XMLSerializer&lt;/code&gt; looks like this:&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;using UnityEngine;

public class XMLSerializer : MonoBehaviour
{
    private void Start()
    {
        Hero knight = new Hero();
        knight.name = &amp;quot;Knight of Solamnia&amp;quot;;
        knight.isBoss = true;
        knight.hitPoints = 100;
        knight.baseDamage = 50f;

        XMLOp.Serialize(knight, &amp;quot;hero.xml&amp;quot;);
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;xml-serialization&quot;&gt;XML Serialization&lt;/h2&gt;

&lt;p&gt;As I have mentioned above, to change the behaviour of XML &lt;abbr title=&quot;Converting objects into a form (such as JSON, or XML) that can be easily transported.&quot;&gt;serialization&lt;/abbr&gt;, we need to modify our class with XML &lt;abbr title=&quot;A method to associate declarative information with the code&quot;&gt;attributes&lt;/abbr&gt;. As you can see &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/83y7df3e%28v=vs.110%29.aspx&quot;&gt;here&lt;/a&gt; there are many XML &lt;abbr title=&quot;A method to associate declarative information with the code&quot;&gt;attributes&lt;/abbr&gt; that control &lt;abbr title=&quot;Converting objects into a form (such as JSON, or XML) that can be easily transported.&quot;&gt;serialization&lt;/abbr&gt;, but in this post, I will only cover the following:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;[XmlElement]&lt;/li&gt;
  &lt;li&gt;[XmlAttribute]&lt;/li&gt;
  &lt;li&gt;[XmlIgnore]&lt;/li&gt;
  &lt;li&gt;[XmlRoot]&lt;/li&gt;
  &lt;li&gt;[XmlArray]&lt;/li&gt;
  &lt;li&gt;[XmlArrayItem]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Usage of an XML attribute is very simple: you type the necessary attribute above your field or class just like the following:&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;[XmlElement(&amp;quot;Name&amp;quot;)]
public string Name;&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;xmlelementstring&quot;&gt;[XmlElement(String)]&lt;/h3&gt;

&lt;p&gt;This attribute indicates that a field will be represented as an XML element. Fields of an object is serialized as XMLElement as default, so this attribute is necessary only to change the name of a field (or force an array to act like an element but we will get to that later). Let’s modify our script file and see what kind of XML file it produces:&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;using System.Xml.Serialization;

public class Hero
{
    [XmlElement(&amp;quot;n&amp;quot;)]
    public string name;

    public bool isBoss;

    public int hitPoints;

    public float baseDamage;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the output becomes:&lt;/p&gt;

&lt;pre class=&quot;language-xml  line-numbers &quot;&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;Hero xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xmlns:xsd=&amp;quot;http://www.w3.org/2001/XMLSchema&amp;quot;&amp;gt;
    &amp;lt;n&amp;gt;Knight of Solamnia&amp;lt;/n&amp;gt;
    &amp;lt;hitPoints&amp;gt;100&amp;lt;/hitPoints&amp;gt;
    &amp;lt;baseDamage&amp;gt;50&amp;lt;/baseDamage&amp;gt;
    &amp;lt;isBoss&amp;gt;true&amp;lt;/isBoss&amp;gt;
&amp;lt;/Hero&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: XML &lt;abbr title=&quot;A method to associate declarative information with the code&quot;&gt;attributes&lt;/abbr&gt; have more constructors with different signatures than this tutorial covers. For example, &lt;code class=&quot;highlighter-rouge&quot;&gt;XmlElement&lt;/code&gt; also has &lt;code class=&quot;highlighter-rouge&quot;&gt;XmlElement(String, Type)&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;XmlElement(Type)&lt;/code&gt;. However, since this tutorial is planned to be an introductory one, I am not going to cover them here.&lt;/p&gt;

&lt;h3 id=&quot;xmlattributestring&quot;&gt;[XmlAttribute(String)]&lt;/h3&gt;

&lt;p&gt;This attribute indicates that a field will be represented as an XML attribute.&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;using System.Xml.Serialization;

public class Hero
{
    [XmlElement(&amp;quot;n&amp;quot;)]
    public string name;

    [XmlAttribute(&amp;quot;boss&amp;quot;)]
    public bool isBoss;

    public int hitPoints;

    public float baseDamage;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the output becomes:&lt;/p&gt;

&lt;pre class=&quot;language-xml  line-numbers &quot;&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;Hero xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xmlns:xsd=&amp;quot;http://www.w3.org/2001/XMLSchema&amp;quot; boss=&amp;quot;true&amp;quot;&amp;gt;
    &amp;lt;n&amp;gt;Knight of Solamnia&amp;lt;/n&amp;gt;
    &amp;lt;hitPoints&amp;gt;100&amp;lt;/hitPoints&amp;gt;
    &amp;lt;baseDamage&amp;gt;50&amp;lt;/baseDamage&amp;gt;
&amp;lt;/Hero&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;xmlignore&quot;&gt;[XmlIgnore]&lt;/h3&gt;

&lt;p&gt;As I have mentioned before, a field must be public in order to be serialized. This also means that all the public fields will be serialized by the XML serializer. But sometimes, we might need a field to be &lt;strong&gt;not&lt;/strong&gt; serialized without making it private. This is where &lt;code class=&quot;highlighter-rouge&quot;&gt;[XmlIgnore]&lt;/code&gt; comes into play. It indicates that a field will not be represented in the XML file at all.&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;using System.Xml.Serialization;

public class Hero
{
    [XmlElement(&amp;quot;n&amp;quot;)]
    public string name;

    [XmlAttribute(&amp;quot;boss&amp;quot;)]
    public bool isBoss;

    [XmlIgnore]
    public int hitPoints;

    public float baseDamage;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the output becomes:&lt;/p&gt;

&lt;pre class=&quot;language-xml  line-numbers &quot;&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;Hero xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xmlns:xsd=&amp;quot;http://www.w3.org/2001/XMLSchema&amp;quot; boss=&amp;quot;true&amp;quot;&amp;gt;
    &amp;lt;n&amp;gt;Knight of Solamnia&amp;lt;/n&amp;gt;
    &amp;lt;baseDamage&amp;gt;50&amp;lt;/baseDamage&amp;gt;
&amp;lt;/Hero&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;xmlrootstring&quot;&gt;[XmlRoot(String)]&lt;/h3&gt;

&lt;p&gt;The object that is serialized by the XML serializer becomes the root of the XML file. As a result, object’s class name becomes the name of the root tag. Sometimes, we want to use some other name in order to provide clarification. This attribute indicates that the name of the root tag will be the provided string. It should be noted that &lt;code class=&quot;highlighter-rouge&quot;&gt;[XmlRoot]&lt;/code&gt; attribute can only be used on classes, structs, enumerations or interfaces unlike the previous &lt;abbr title=&quot;A method to associate declarative information with the code&quot;&gt;attributes&lt;/abbr&gt;.&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;using System.Xml.Serialization;

[XmlRoot(&amp;quot;Knight&amp;quot;)]
public class Hero
{
    [XmlElement(&amp;quot;n&amp;quot;)]
    public string name;

    [XmlAttribute(&amp;quot;boss&amp;quot;)]
    public bool isBoss;

    [XmlIgnore]
    public int hitPoints;

    public float baseDamage;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the output becomes:&lt;/p&gt;

&lt;pre class=&quot;language-xml  line-numbers &quot;&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;Knight xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xmlns:xsd=&amp;quot;http://www.w3.org/2001/XMLSchema&amp;quot; boss=&amp;quot;true&amp;quot;&amp;gt;
    &amp;lt;n&amp;gt;Knight of Solamnia&amp;lt;/n&amp;gt;
    &amp;lt;baseDamage&amp;gt;50&amp;lt;/baseDamage&amp;gt;
&amp;lt;/Knight&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;xmlarraystring-and-xmlarrayitemstring&quot;&gt;[XmlArray(String)] and [XmlArrayItem(String)]&lt;/h3&gt;
&lt;p&gt;But, how about arrays? What if our Hero has a int array which includes combo rewards?&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;using System.Xml.Serialization;

public class Hero
{
    [XmlElement(&amp;quot;n&amp;quot;)]
    public string name;

    [XmlAttribute(&amp;quot;boss&amp;quot;)]
    public bool isBoss;

    [XmlIgnore]
    public int hitPoints;

    public float baseDamage;

    public int[] comboRewards;
}&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;using UnityEngine;

public class XMLSerializer : MonoBehaviour
{
    private void Start()
    {
        Hero knight = new Hero();
        knight.name = &amp;quot;Knight of Solamnia&amp;quot;;
        knight.isBoss = true;
        knight.hitPoints = 100;
        knight.baseDamage = 50f;
        knight.comboRewards = new int[] { 1, 3, 5 };

        XMLOp.Serialize(knight, &amp;quot;hero.xml&amp;quot;);
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Output of this code would be:&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;Knight xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xmlns:xsd=&amp;quot;http://www.w3.org/2001/XMLSchema&amp;quot; boss=&amp;quot;true&amp;quot;&amp;gt;
    &amp;lt;n&amp;gt;Knight of Solamnia&amp;lt;/n&amp;gt;
    &amp;lt;baseDamage&amp;gt;50&amp;lt;/baseDamage&amp;gt;
    &amp;lt;comboRewards&amp;gt;
        &amp;lt;int&amp;gt;1&amp;lt;/int&amp;gt;
        &amp;lt;int&amp;gt;3&amp;lt;/int&amp;gt;
        &amp;lt;int&amp;gt;5&amp;lt;/int&amp;gt;
    &amp;lt;/comboRewards&amp;gt;
&amp;lt;/Knight&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;comboRewards&amp;gt;&lt;/code&gt; tag is OK, but those &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;int&amp;gt;&lt;/code&gt; tags don’t look nice, do they? Fortunately, there are two XML &lt;abbr title=&quot;A method to associate declarative information with the code&quot;&gt;attributes&lt;/abbr&gt; which modify the XML output of an array: &lt;code class=&quot;highlighter-rouge&quot;&gt;[XmlArray(string)]&lt;/code&gt; which modifies the name of the array, and &lt;code class=&quot;highlighter-rouge&quot;&gt;[XmlArrayItem(string)]&lt;/code&gt; which, as you might have guessed, modifies the name of the array items.&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;using System.Xml.Serialization;

public class Hero
{
    [XmlElement(&amp;quot;n&amp;quot;)]
    public string name;

    [XmlAttribute(&amp;quot;boss&amp;quot;)]
    public bool isBoss;

    [XmlIgnore]
    public int hitPoints;

    public float baseDamage;

    [XmlArray(&amp;quot;rewards&amp;quot;), XmlArrayItem(&amp;quot;reward&amp;quot;)]
    public int[] comboRewards;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And this would produce a better output:&lt;/p&gt;

&lt;pre class=&quot;language-xml  line-numbers &quot;&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;Knight xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xmlns:xsd=&amp;quot;http://www.w3.org/2001/XMLSchema&amp;quot; boss=&amp;quot;true&amp;quot;&amp;gt;
    &amp;lt;n&amp;gt;Knight of Solamnia&amp;lt;/n&amp;gt;
    &amp;lt;baseDamage&amp;gt;50&amp;lt;/baseDamage&amp;gt;
    &amp;lt;rewards&amp;gt;
        &amp;lt;reward&amp;gt;1&amp;lt;/reward&amp;gt;
        &amp;lt;reward&amp;gt;3&amp;lt;/reward&amp;gt;
        &amp;lt;reward&amp;gt;5&amp;lt;/reward&amp;gt;
    &amp;lt;/rewards&amp;gt;
&amp;lt;/Knight&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;xml-deserialization&quot;&gt;XML Deserialization&lt;/h2&gt;

&lt;p&gt;We have successfully saved our game data in an XML file, but currently it is pretty useless, because we can’t take that data back into our game. In order to do that, we need to read the XML file and create objects (namely, deserialize it). Deserialization is simpler than &lt;abbr title=&quot;Converting objects into a form (such as JSON, or XML) that can be easily transported.&quot;&gt;serialization&lt;/abbr&gt;, because we already defined the structure in our class. All we need to do is just add a few lines of code to our &lt;code class=&quot;highlighter-rouge&quot;&gt;XMLOp.cs&lt;/code&gt;:&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;using System.IO;
using System.Xml.Serialization;

public class XMLOp
{
	public static void Serialize(object item, string path)
	{
		XmlSerializer serializer = new XmlSerializer(item.GetType());
		StreamWriter writer = new StreamWriter(path);
		serializer.Serialize(writer.BaseStream, item);
		writer.Close();
	}

	public static T Deserialize&amp;lt;T&amp;gt;(string path)
	{
		XmlSerializer serializer = new XmlSerializer(typeof(T));
		StreamReader reader = new StreamReader(path);
		T deserialized = (T)serializer.Deserialize(reader.BaseStream);
		reader.Close();
		return deserialized;
	}
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Deserialization process is very similar to &lt;abbr title=&quot;Converting objects into a form (such as JSON, or XML) that can be easily transported.&quot;&gt;serialization&lt;/abbr&gt; process:&lt;/p&gt;

&lt;p&gt;On &lt;strong&gt;Line 16&lt;/strong&gt;, we create an &lt;code class=&quot;highlighter-rouge&quot;&gt;XmlSerializer&lt;/code&gt; instance with type of T so that it can take any type to deserialize.&lt;/p&gt;

&lt;p&gt;On &lt;strong&gt;Line 17&lt;/strong&gt;, we create a &lt;code class=&quot;highlighter-rouge&quot;&gt;StreamReader&lt;/code&gt; instance which would read the XML file.&lt;/p&gt;

&lt;p&gt;On &lt;strong&gt;Line 18&lt;/strong&gt;, we tell the &lt;code class=&quot;highlighter-rouge&quot;&gt;XmlSerializer&lt;/code&gt; to deserialize the stream and cast it to our target type T.&lt;/p&gt;

&lt;p&gt;On &lt;strong&gt;Line 19&lt;/strong&gt;, we tell reader to close streaming and then on &lt;strong&gt;Line 20&lt;/strong&gt; we return the deserialized object.&lt;/p&gt;

&lt;p&gt;Let’s say, we have already serialized our weapon object and created the XML file. Now we can deserialize it in another script:&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;using UnityEngine;

public class XMLDeserializer : MonoBehaviour
{
    private void Start()
    {
        Hero hero = XMLOp.Deserialize&amp;lt;Hero&amp;gt;(&amp;quot;hero.xml&amp;quot;);
        Debug.Log(hero.name);
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;This concludes our tutorial, and as you can see, XML &lt;abbr title=&quot;Converting objects into a form (such as JSON, or XML) that can be easily transported.&quot;&gt;serialization&lt;/abbr&gt; in Unity (in C# actually) is pretty easy. All you have to do is to use XML &lt;abbr title=&quot;A method to associate declarative information with the code&quot;&gt;attributes&lt;/abbr&gt; in your classes to modify &lt;abbr title=&quot;Converting objects into a form (such as JSON, or XML) that can be easily transported.&quot;&gt;serialization&lt;/abbr&gt; behaviour.&lt;/p&gt;

&lt;p&gt;As always, here are the scripts in full, below. Until next time.&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;using System.Xml.Serialization;

[XmlRoot(&amp;quot;Knight&amp;quot;)]
public class Hero
{
    [XmlElement(&amp;quot;n&amp;quot;)]
    public string name;

    [XmlAttribute(&amp;quot;boss&amp;quot;)]
    public bool isBoss;

    [XmlIgnore]
    public int hitPoints;

    public float baseDamage;

    [XmlArray(&amp;quot;rewards&amp;quot;), XmlArrayItem(&amp;quot;reward&amp;quot;)]
    public int[] comboRewards;
}&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;using UnityEngine;

public class XMLSerializer : MonoBehaviour
{
    private void Start()
    {
        Hero knight = new Hero();
        knight.name = &amp;quot;Knight of Solamnia&amp;quot;;
        knight.hitPoints = 100;
        knight.baseDamage = 50f;
        knight.isBoss = true;
        knight.comboRewards = new int[] { 1, 3, 5 };

        XMLOp.Serialize(knight, &amp;quot;hero.xml&amp;quot;);
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;using UnityEngine;

public class XMLDeserializer : MonoBehaviour
{
    private void Start()
    {
        Hero hero = XMLOp.Deserialize&amp;lt;Hero&amp;gt;(&amp;quot;hero.xml&amp;quot;);
        Debug.Log(hero.name);
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;using System.IO;
using System.Xml.Serialization;

public class XMLOp
{
    public static void Serialize(object item, string path)
    {
        XmlSerializer serializer = new XmlSerializer(item.GetType());
        StreamWriter writer = new StreamWriter(path);
        serializer.Serialize(writer.BaseStream, item);
        writer.Close();
    }

    public static T Deserialize&amp;lt;T&amp;gt;(string path)
    {
        XmlSerializer serializer = new XmlSerializer(typeof(T));
        StreamReader reader = new StreamReader(path);
        T deserialized = (T)serializer.Deserialize(reader.BaseStream);
        reader.Close();
        return deserialized;
    }
}&lt;/code&gt;&lt;/pre&gt;</content><author><name>Oguz Konya</name></author><summary type="html"></summary></entry><entry><title type="html">Creating a Node Based Editor in Unity</title><link href="https://oguzkonya.github.io/creating-node-based-editor-unity/" rel="alternate" type="text/html" title="Creating a Node Based Editor in Unity" /><published>2019-08-15T00:00:00+00:00</published><updated>2019-08-15T00:00:00+00:00</updated><id>https://oguzkonya.github.io/creating-node-based-editor-unity</id><content type="html" xml:base="https://oguzkonya.github.io/creating-node-based-editor-unity/">&lt;p&gt;Node based editors are frequently used in game engines; Unity has Animator window, Unreal Engine has blueprint system, some other game engines have dialogue systems. In this blog post, we will create our own node based editor in Unity. It’s going to be simple node editor that you’ll be able to improve upon later (see the below image for an example). I am going to assume that you are already familiar with editor scripting, but if you are not, please take your time to have a look at &lt;a href=&quot;/creating-editor-windows-in-unity/&quot;&gt;this&lt;/a&gt; post and &lt;a href=&quot;/creating-clone-unitys-console-window/&quot;&gt;this&lt;/a&gt; post.&lt;/p&gt;

&lt;div class=&quot;img-wrapper&quot;&gt;
    
    &lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;/assets/img/node-based-editor.gif&quot;&gt;
    
        &lt;img src=&quot;/assets/img/node-based-editor.gif&quot; class=&quot;center&quot; alt=&quot;Window&quot; width=&quot;300px&quot; /&gt;
    
    &lt;/a&gt;
    
    &lt;em&gt;We will be creating this window in this post (click to see the gif in action)&lt;/em&gt;
&lt;/div&gt;

&lt;h3 id=&quot;creating-the-window&quot;&gt;Creating the Window&lt;/h3&gt;

&lt;p&gt;Let’s start by creating a simple editor window. The structure of the code will be similar to that of the console clone we developed in the previous posts: draw the elements first, and then process input, and if the GUI is changed due to input events, force the window to repaint.&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;using UnityEngine;
using UnityEditor;
using System.Collections.Generic;

public class NodeBasedEditor : EditorWindow
{
    [MenuItem(&amp;quot;Window/Node Based Editor&amp;quot;)]
    private static void OpenWindow()
    {
        NodeBasedEditor window = GetWindow&amp;lt;NodeBasedEditor&amp;gt;();
        window.titleContent = new GUIContent(&amp;quot;Node Based Editor&amp;quot;);
    }

    private void OnGUI()
    {
        DrawNodes();

        ProcessEvents(Event.current);

        if (GUI.changed) Repaint();
    }

    private void DrawNodes()
    {
    }

    private void ProcessEvents(Event e)
    {
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;drawing-nodes&quot;&gt;Drawing Nodes&lt;/h3&gt;

&lt;p&gt;Well, since this is a node editor, it should contain a list of nodes, which requires us to define a List&lt;Node&gt;. But first we should define __Node__ class. A __Node__ will be responsible for drawing itself and processing its own events. Unlike __ProcessEvents(Event e)__ in __NodeBasedEditor__, __ProcessEvents(Event e)__ in __Node__ will return a boolean so that we can check whether we should repaint the GUI or not.&lt;/Node&gt;&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;using System;
using UnityEditor;
using UnityEngine;

public class Node
{
    public Rect rect;
    public string title;

    public GUIStyle style;

    public Node(Vector2 position, float width, float height, GUIStyle nodeStyle)
    {
        rect = new Rect(position.x, position.y, width, height);
        style = nodeStyle;
    }

    public void Drag(Vector2 delta)
    {
        rect.position += delta;
    }

    public void Draw()
    {
        GUI.Box(rect, title, style);
    }

    public bool ProcessEvents(Event e)
    {
        return false;
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;using UnityEngine;
using UnityEditor;
using System.Collections.Generic;

public class NodeBasedEditor : EditorWindow
{
    private List&amp;lt;Node&amp;gt; nodes;

    [MenuItem(&amp;quot;Window/Node Based Editor&amp;quot;)]
    private static void OpenWindow()
    {
        NodeBasedEditor window = GetWindow&amp;lt;NodeBasedEditor&amp;gt;();
        window.titleContent = new GUIContent(&amp;quot;Node Based Editor&amp;quot;);
    }

    private void OnGUI()
    {
        DrawNodes();

        ProcessEvents(Event.current);

        if (GUI.changed) Repaint();
    }

    private void DrawNodes()
    {
        if (nodes != null)
        {
            for (int i = 0; i &amp;lt; nodes.Count; i++)
            {
                nodes[i].Draw();
            }
        }
    }

    private void ProcessEvents(Event e)
    {
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;creating-nodes&quot;&gt;Creating Nodes&lt;/h3&gt;

&lt;p&gt;Nodes are drawn in the editor now, but we can’t see them if we don’t create them. We should display a context menu with an “Add node” item when the user right clicks in the editor. When the user clicks “Add node”, we will create a &lt;strong&gt;Node&lt;/strong&gt; and add it to the list of nodes, so that it is drawn. A &lt;strong&gt;Node&lt;/strong&gt; requires a position, a width, a height and a styling; position will be the mouse’s current position, width will be 200, height will be 50 (yes, I don’t like using magic numbers in code, but this is going to be a simple editor, so the size doesn’t matter for the moment) and we will replicate the Animator window’s node style for styling.&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;using UnityEngine;
using UnityEditor;
using System.Collections.Generic;

public class NodeBasedEditor : EditorWindow
{
    private List&amp;lt;Node&amp;gt; nodes;

    private GUIStyle nodeStyle;

    [MenuItem(&amp;quot;Window/Node Based Editor&amp;quot;)]
    private static void OpenWindow()
    {
        NodeBasedEditor window = GetWindow&amp;lt;NodeBasedEditor&amp;gt;();
        window.titleContent = new GUIContent(&amp;quot;Node Based Editor&amp;quot;);
    }

    private void OnEnable()
    {
        nodeStyle = new GUIStyle();
        nodeStyle.normal.background = EditorGUIUtility.Load(&amp;quot;builtin skins/darkskin/images/node1.png&amp;quot;) as Texture2D;
        nodeStyle.border = new RectOffset(12, 12, 12, 12);
    }

    private void OnGUI()
    {
        DrawNodes();

        ProcessEvents(Event.current);

        if (GUI.changed) Repaint();
    }

    private void DrawNodes()
    {
        if (nodes != null)
        {
            for (int i = 0; i &amp;lt; nodes.Count; i++)
            {
                nodes[i].Draw();
            }
        }
    }

    private void ProcessEvents(Event e)
    {
        switch (e.type)
        {
            case EventType.MouseDown:
                if (e.button == 1)
                {
                    ProcessContextMenu(e.mousePosition);
                }
                break;
        }
    }

    private void ProcessContextMenu(Vector2 mousePosition)
    {
        GenericMenu genericMenu = new GenericMenu();
        genericMenu.AddItem(new GUIContent(&amp;quot;Add node&amp;quot;), false, () =&amp;gt; OnClickAddNode(mousePosition)); 
        genericMenu.ShowAsContext();
    }

    private void OnClickAddNode(Vector2 mousePosition)
    {
        if (nodes == null)
        {
            nodes = new List&amp;lt;Node&amp;gt;();
        }

        nodes.Add(new Node(mousePosition, 200, 50, nodeStyle));
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;making-nodes-draggable&quot;&gt;Making Nodes Draggable&lt;/h3&gt;

&lt;p&gt;Alright, now we are able to add nodes, but we can’t drag them around. As I mentioned earlier, nodes will be processing their own events, hence we will be handling drag event in &lt;strong&gt;Node&lt;/strong&gt; class. One important thing to note here is that we should be “using” the drag event with &lt;strong&gt;Use()&lt;/strong&gt; method. Later on, we will be adding canvas dragging, and we wouldn’t want to drag a node and the whole canvas at the same time (“using” an event prevents it being used by other processes, i.e. it stops event bubbling). Also note that the for loop in &lt;strong&gt;ProcessNodeEvents(Event e)&lt;/strong&gt; traverses the node list backwards, because the last node is drawn at the top, so it should process the events first.&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;using System;
using UnityEditor;
using UnityEngine;

public class Node
{
    public Rect rect;
    public string title;
    public bool isDragged;

    public GUIStyle style;

    public Node(Vector2 position, float width, float height, GUIStyle nodeStyle)
    {
        rect = new Rect(position.x, position.y, width, height);
        style = nodeStyle;
    }

    public void Drag(Vector2 delta)
    {
        rect.position += delta;
    }

    public void Draw()
    {
        GUI.Box(rect, title, style);
    }

    public bool ProcessEvents(Event e)
    {
        switch (e.type)
        {
            case EventType.MouseDown:
                if (e.button == 0)
                {
                    if (rect.Contains(e.mousePosition))
                    {
                        isDragged = true;
                        GUI.changed = true;
                    }
                    else
                    {
                        GUI.changed = true;
                    }
                }
                break;

            case EventType.MouseUp:
                isDragged = false;
                break;

            case EventType.MouseDrag:
                if (e.button == 0 &amp;amp;amp;&amp;amp;amp; isDragged)
                {
                    Drag(e.delta);
                    e.Use();
                    return true;
                }
                break;
        }

        return false;
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;    private void OnGUI()
    {
        DrawNodes();

        ProcessNodeEvents(Event.current);
        ProcessEvents(Event.current);

        if (GUI.changed) Repaint();
    }

    private void DrawNodes()
    {
        if (nodes != null)
        {
            for (int i = 0; i &amp;lt; nodes.Count; i++)
            {
                nodes[i].Draw();
            }
        }
    }

    private void ProcessEvents(Event e)
    {
        switch (e.type)
        {
            case EventType.MouseDown:
                if (e.button == 1)
                {
                    ProcessContextMenu(e.mousePosition);
                }
                break;
        }
    }

    private void ProcessNodeEvents(Event e)
    {
        if (nodes != null)
        {
            for (int i = nodes.Count - 1; i &amp;gt;= 0; i--)
            {
                bool guiChanged = nodes[i].ProcessEvents(e);

                if (guiChanged)
                {
                    GUI.changed = true;
                }
            }
        }
    }
	
    private void ProcessContextMenu(Vector2 mousePosition)
    {
        GenericMenu genericMenu = new GenericMenu();
        genericMenu.AddItem(new GUIContent(&amp;quot;Add node&amp;quot;), false, () =&amp;gt; OnClickAddNode(mousePosition)); 
        genericMenu.ShowAsContext();
    }&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;creating-connections-between-nodes&quot;&gt;Creating Connections Between Nodes&lt;/h3&gt;

&lt;p&gt;Our node editor now has nodes, but we should also be able to connect them. In order to do this, we need two connection points (in and out) on a node and a connection between them. A connection point has a rectangle (so that we can draw it), has a type (in or out), has a style and it references its parent node. Therefore, our &lt;strong&gt;ConnectionPoint&lt;/strong&gt; class will be a very simple one; drawing a button at a specific position and doing an action when this button is clicked.&lt;/p&gt;

&lt;p&gt;On the other hand, a connection has two connection points and an action to remove it. &lt;strong&gt;Connection&lt;/strong&gt; class is much simpler than &lt;strong&gt;ConnectionPoint&lt;/strong&gt;, however, it introduces a new concept: &lt;strong&gt;Handles&lt;/strong&gt;. This class is actually used to draw 3D GUI controls in the &lt;strong&gt;Scene&lt;/strong&gt; view, but it is the only class with a bezier drawing method: &lt;strong&gt;Handles.DrawBezier(Vector3, Vector3, Vector3, Vector3, Color, Texture2D, float).&lt;/strong&gt; It takes 7 parameters and the first 4 parameters are the position controls (start position, end position, start tangent, and end tangent), while the rest determine how the bezier looks.&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;using System;
using UnityEngine;

public enum ConnectionPointType { In, Out }

public class ConnectionPoint
{
    public Rect rect;

    public ConnectionPointType type;

    public Node node;

    public GUIStyle style;

    public Action&amp;lt;ConnectionPoint&amp;gt; OnClickConnectionPoint;
    
    public ConnectionPoint(Node node, ConnectionPointType type, GUIStyle style, Action&amp;lt;ConnectionPoint&amp;gt; OnClickConnectionPoint)
    {
        this.node = node;
        this.type = type;
        this.style = style;
        this.OnClickConnectionPoint = OnClickConnectionPoint;
        rect = new Rect(0, 0, 10f, 20f);
    }

    public void Draw()
    {
        rect.y = node.rect.y + (node.rect.height * 0.5f) - rect.height * 0.5f;

        switch (type)
        {
            case ConnectionPointType.In:
                rect.x = node.rect.x - rect.width + 8f;
                break;

            case ConnectionPointType.Out:
                rect.x = node.rect.x + node.rect.width - 8f;
                break;
        }
        
        if (GUI.Button(rect, &amp;quot;&amp;quot;, style))
        {
            if (OnClickConnectionPoint != null)
            {
                OnClickConnectionPoint(this);
            }
        }
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;using System;
using UnityEditor;
using UnityEngine;

public class Connection
{
    public ConnectionPoint inPoint;
    public ConnectionPoint outPoint;
    public Action&amp;lt;Connection&amp;gt; OnClickRemoveConnection;

    public Connection(ConnectionPoint inPoint, ConnectionPoint outPoint, Action&amp;lt;Connection&amp;gt; OnClickRemoveConnection)
    {
        this.inPoint = inPoint;
        this.outPoint = outPoint;
        this.OnClickRemoveConnection = OnClickRemoveConnection;
    }

    public void Draw()
    {
        Handles.DrawBezier(
            inPoint.rect.center,
            outPoint.rect.center,
            inPoint.rect.center + Vector2.left * 50f,
            outPoint.rect.center - Vector2.left * 50f,
            Color.white,
            null,
            2f
        );

        if (Handles.Button((inPoint.rect.center + outPoint.rect.center) * 0.5f, Quaternion.identity, 4, 8, Handles.RectangleCap))
        {
            if (OnClickRemoveConnection != null)
            {
                OnClickRemoveConnection(this);
            }
        }
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;drawing-connections&quot;&gt;Drawing Connections&lt;/h3&gt;

&lt;p&gt;Since the &lt;strong&gt;Connection&lt;/strong&gt; and &lt;strong&gt;ConnectionPoint&lt;/strong&gt; classes are ready, all we have to do is draw connection points in &lt;strong&gt;Node&lt;/strong&gt; class and draw connections in &lt;strong&gt;NodeBasedEditor&lt;/strong&gt;. Changes in &lt;strong&gt;Node&lt;/strong&gt; class will be minimal; we will define two connection points, modify the constructor so that we can pass the styling and actions for them, and draw them in &lt;strong&gt;Draw()&lt;/strong&gt; method.&lt;/p&gt;

&lt;p&gt;However, &lt;strong&gt;NodeBasedEditor&lt;/strong&gt; needs significant modification. First of all, we need to define styles for connection points. You can use a single style for both of them, but I would like them to look different, so I will be using separate styles for each. We are going to initialize these styles in &lt;strong&gt;OnEnable()&lt;/strong&gt; just like we initialized node style.&lt;/p&gt;

&lt;p&gt;Secondly, we need to keep track of clicked connection points, so that when a user selects an &lt;strong&gt;in&lt;/strong&gt; and &lt;strong&gt;out&lt;/strong&gt;, we should create a connection between them. This step includes most of the additions:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;OnClickInPoint(ConnectionPoint) handles clicking an &lt;strong&gt;in&lt;/strong&gt; point.&lt;/li&gt;
  &lt;li&gt;OnClickOutPoint(ConnectionPoint) handles clicking an &lt;strong&gt;out&lt;/strong&gt; point.&lt;/li&gt;
  &lt;li&gt;OnClickRemoveConnection(Connection) handles clicking the remove button on connections.&lt;/li&gt;
  &lt;li&gt;CreateConnection() creates a connection when an &lt;strong&gt;in&lt;/strong&gt; and an &lt;strong&gt;out&lt;/strong&gt; point is selected.&lt;/li&gt;
  &lt;li&gt;ClearConnectionSelection() clears selected points.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And lastly, we need to draw connections in &lt;strong&gt;OnGUI()&lt;/strong&gt; just like we draw nodes.&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;using System;
using UnityEditor;
using UnityEngine;

public class Node
{
    public Rect rect;
    public string title;
    public bool isDragged;

    public ConnectionPoint inPoint;
    public ConnectionPoint outPoint;

    public GUIStyle style;

    public Node(Vector2 position, float width, float height, GUIStyle nodeStyle, GUIStyle inPointStyle, GUIStyle outPointStyle, Action&amp;lt;ConnectionPoint&amp;gt; OnClickInPoint, Action&amp;lt;ConnectionPoint&amp;gt; OnClickOutPoint)
    {
        rect = new Rect(position.x, position.y, width, height);
        style = nodeStyle;
        inPoint = new ConnectionPoint(this, ConnectionPointType.In, inPointStyle, OnClickInPoint);
        outPoint = new ConnectionPoint(this, ConnectionPointType.Out, outPointStyle, OnClickOutPoint);
    }

    public void Drag(Vector2 delta)
    {
        rect.position += delta;
    }

    public void Draw()
    {
        inPoint.Draw();
        outPoint.Draw();
        GUI.Box(rect, title, style);
    }

    public bool ProcessEvents(Event e)
    {
        switch (e.type)
        {
            case EventType.MouseDown:
                if (e.button == 0)
                {
                    if (rect.Contains(e.mousePosition))
                    {
                        isDragged = true;
                        GUI.changed = true;
                    }
                    else
                    {
                        GUI.changed = true;
                    }
                }
                break;

            case EventType.MouseUp:
                isDragged = false;
                break;

            case EventType.MouseDrag:
                if (e.button == 0 &amp;amp;amp;&amp;amp;amp; isDragged)
                {
                    Drag(e.delta);
                    e.Use();
                    return true;
                }
                break;
        }

        return false;
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;using UnityEngine;
using UnityEditor;
using System.Collections.Generic;

public class NodeBasedEditor : EditorWindow
{
    private List&amp;lt;Node&amp;gt; nodes;
    private List&amp;lt;Connection&amp;gt; connections;

    private GUIStyle nodeStyle;
    private GUIStyle inPointStyle;
    private GUIStyle outPointStyle;

    private ConnectionPoint selectedInPoint;
    private ConnectionPoint selectedOutPoint;

    [MenuItem(&amp;quot;Window/Node Based Editor&amp;quot;)]
    private static void OpenWindow()
    {
        NodeBasedEditor window = GetWindow&amp;lt;NodeBasedEditor&amp;gt;();
        window.titleContent = new GUIContent(&amp;quot;Node Based Editor&amp;quot;);
    }

    private void OnEnable()
    {
        nodeStyle = new GUIStyle();
        nodeStyle.normal.background = EditorGUIUtility.Load(&amp;quot;builtin skins/darkskin/images/node1.png&amp;quot;) as Texture2D;
        nodeStyle.border = new RectOffset(12, 12, 12, 12);
		
        inPointStyle = new GUIStyle();
        inPointStyle.normal.background = EditorGUIUtility.Load(&amp;quot;builtin skins/darkskin/images/btn left.png&amp;quot;) as Texture2D;
        inPointStyle.active.background = EditorGUIUtility.Load(&amp;quot;builtin skins/darkskin/images/btn left on.png&amp;quot;) as Texture2D;
        inPointStyle.border = new RectOffset(4, 4, 12, 12);

        outPointStyle = new GUIStyle();
        outPointStyle.normal.background = EditorGUIUtility.Load(&amp;quot;builtin skins/darkskin/images/btn right.png&amp;quot;) as Texture2D;
        outPointStyle.active.background = EditorGUIUtility.Load(&amp;quot;builtin skins/darkskin/images/btn right on.png&amp;quot;) as Texture2D;
        outPointStyle.border = new RectOffset(4, 4, 12, 12);
    }

    private void OnGUI()
    {
        DrawNodes();
        DrawConnections();

        ProcessNodeEvents(Event.current);
        ProcessEvents(Event.current);

        if (GUI.changed) Repaint();
    }

    private void DrawNodes()
    {
        if (nodes != null)
        {
            for (int i = 0; i &amp;lt; nodes.Count; i++)
            {
                nodes[i].Draw();
            }
        }
    }

    private void DrawConnections()
    {
        if (connections != null)
        {
            for (int i = 0; i &amp;lt; connections.Count; i++)
            {
                connections[i].Draw();
            } 
        }
    }

    private void ProcessEvents(Event e)
    {
        switch (e.type)
        {
            case EventType.MouseDown:
                if (e.button == 0)
                {
                    ClearConnectionSelection();
                }

                if (e.button == 1)
                {
                    ProcessContextMenu(e.mousePosition);
                }
                break;
        }
    }

    private void ProcessNodeEvents(Event e)
    {
        if (nodes != null)
        {
            for (int i = nodes.Count - 1; i &amp;gt;= 0; i--)
            {
                bool guiChanged = nodes[i].ProcessEvents(e);

                if (guiChanged)
                {
                    GUI.changed = true;
                }
            }
        }
    }
	
    private void ProcessContextMenu(Vector2 mousePosition)
    {
        GenericMenu genericMenu = new GenericMenu();
        genericMenu.AddItem(new GUIContent(&amp;quot;Add node&amp;quot;), false, () =&amp;gt; OnClickAddNode(mousePosition)); 
        genericMenu.ShowAsContext();
    }

    private void OnClickAddNode(Vector2 mousePosition)
    {
        if (nodes == null)
        {
            nodes = new List&amp;lt;Node&amp;gt;();
        }

        nodes.Add(new Node(mousePosition, 200, 50, nodeStyle, inPointStyle, outPointStyle, OnClickInPoint, OnClickOutPoint));
    }

    private void OnClickInPoint(ConnectionPoint inPoint)
    {
        selectedInPoint = inPoint;

        if (selectedOutPoint != null)
        {
            if (selectedOutPoint.node != selectedInPoint.node)
            {
                CreateConnection();
                ClearConnectionSelection(); 
            }
            else
            {
                ClearConnectionSelection();
            }
        }
    }

    private void OnClickOutPoint(ConnectionPoint outPoint)
    {
        selectedOutPoint = outPoint;

        if (selectedInPoint != null)
        {
            if (selectedOutPoint.node != selectedInPoint.node)
            {
                CreateConnection();
                ClearConnectionSelection();
            }
            else
            {
                ClearConnectionSelection();
            }
        }
    }

    private void OnClickRemoveConnection(Connection connection)
    {
        connections.Remove(connection);
    }

    private void CreateConnection()
    {
        if (connections == null)
        {
            connections = new List&amp;lt;Connection&amp;gt;();
        }

        connections.Add(new Connection(selectedInPoint, selectedOutPoint, OnClickRemoveConnection));
    }

    private void ClearConnectionSelection()
    {
        selectedInPoint = null;
        selectedOutPoint = null;
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;selecting-nodes&quot;&gt;Selecting Nodes&lt;/h3&gt;

&lt;p&gt;We should provide feedback when the user clicks on a node so that they would know which node they selected (or if a node is selected at all). This is going to be useful when a user wants to remove a node.&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;using System;
using UnityEditor;
using UnityEngine;

public class Node
{
    public Rect rect;
    public string title;
    public bool isDragged;
    public bool isSelected;

    public ConnectionPoint inPoint;
    public ConnectionPoint outPoint;

    public GUIStyle style;
    public GUIStyle defaultNodeStyle;
    public GUIStyle selectedNodeStyle;

    public Node(Vector2 position, float width, float height, GUIStyle nodeStyle, GUIStyle selectedStyle, GUIStyle inPointStyle, GUIStyle outPointStyle, Action&amp;lt;ConnectionPoint&amp;gt; OnClickInPoint, Action&amp;lt;ConnectionPoint&amp;gt; OnClickOutPoint)
    {
        rect = new Rect(position.x, position.y, width, height);
        style = nodeStyle;
        inPoint = new ConnectionPoint(this, ConnectionPointType.In, inPointStyle, OnClickInPoint);
        outPoint = new ConnectionPoint(this, ConnectionPointType.Out, outPointStyle, OnClickOutPoint);
        defaultNodeStyle = nodeStyle;
        selectedNodeStyle = selectedStyle;
    }

    public void Drag(Vector2 delta)
    {
        rect.position += delta;
    }

    public void Draw()
    {
        inPoint.Draw();
        outPoint.Draw();
        GUI.Box(rect, title, style);
    }

    public bool ProcessEvents(Event e)
    {
        switch (e.type)
        {
            case EventType.MouseDown:
                if (e.button == 0)
                {
                    if (rect.Contains(e.mousePosition))
                    {
                        isDragged = true;
                        GUI.changed = true;
                        isSelected = true;
                        style = selectedNodeStyle;
                    }
                    else
                    {
                        GUI.changed = true;
                        isSelected = false;
                        style = defaultNodeStyle;
                    }
                }
                break;

            case EventType.MouseUp:
                isDragged = false;
                break;

            case EventType.MouseDrag:
                if (e.button == 0 &amp;amp;amp;&amp;amp;amp; isDragged)
                {
                    Drag(e.delta);
                    e.Use();
                    return true;
                }
                break;
        }

        return false;
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;using UnityEngine;
using UnityEditor;
using System.Collections.Generic;

public class NodeBasedEditor : EditorWindow
{
    private List&amp;lt;Node&amp;gt; nodes;
    private List&amp;lt;Connection&amp;gt; connections;

    private GUIStyle nodeStyle;
    private GUIStyle selectedNodeStyle;
    private GUIStyle inPointStyle;
    private GUIStyle outPointStyle;

    private ConnectionPoint selectedInPoint;
    private ConnectionPoint selectedOutPoint;

    [MenuItem(&amp;quot;Window/Node Based Editor&amp;quot;)]
    private static void OpenWindow()
    {
        NodeBasedEditor window = GetWindow&amp;lt;NodeBasedEditor&amp;gt;();
        window.titleContent = new GUIContent(&amp;quot;Node Based Editor&amp;quot;);
    }

    private void OnEnable()
    {
        nodeStyle = new GUIStyle();
        nodeStyle.normal.background = EditorGUIUtility.Load(&amp;quot;builtin skins/darkskin/images/node1.png&amp;quot;) as Texture2D;
        nodeStyle.border = new RectOffset(12, 12, 12, 12);

        selectedNodeStyle = new GUIStyle();
        selectedNodeStyle.normal.background = EditorGUIUtility.Load(&amp;quot;builtin skins/darkskin/images/node1 on.png&amp;quot;) as Texture2D;
        selectedNodeStyle.border = new RectOffset(12, 12, 12, 12);

        inPointStyle = new GUIStyle();
        inPointStyle.normal.background = EditorGUIUtility.Load(&amp;quot;builtin skins/darkskin/images/btn left.png&amp;quot;) as Texture2D;
        inPointStyle.active.background = EditorGUIUtility.Load(&amp;quot;builtin skins/darkskin/images/btn left on.png&amp;quot;) as Texture2D;
        inPointStyle.border = new RectOffset(4, 4, 12, 12);

        outPointStyle = new GUIStyle();
        outPointStyle.normal.background = EditorGUIUtility.Load(&amp;quot;builtin skins/darkskin/images/btn right.png&amp;quot;) as Texture2D;
        outPointStyle.active.background = EditorGUIUtility.Load(&amp;quot;builtin skins/darkskin/images/btn right on.png&amp;quot;) as Texture2D;
        outPointStyle.border = new RectOffset(4, 4, 12, 12);
    }

    ...&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;    private void OnClickAddNode(Vector2 mousePosition)
    {
        if (nodes == null)
        {
            nodes = new List&amp;lt;Node&amp;gt;();
        }

        nodes.Add(new Node(mousePosition, 200, 50, nodeStyle, selectedNodeStyle, inPointStyle, outPointStyle, OnClickInPoint, OnClickOutPoint));
    }&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;removing-nodes&quot;&gt;Removing Nodes&lt;/h3&gt;

&lt;p&gt;Some node editors prefer to put the &lt;strong&gt;remove node&lt;/strong&gt; button on the node itself, but in our case it might be dangerous: the user might remove a node accidentally. So, we are going to do the next best thing: put that button on a context menu. Users should select the node first and then right click on it in order to access the &lt;strong&gt;remove node&lt;/strong&gt; button. When the user clicks &lt;strong&gt;remove node&lt;/strong&gt;, we will remove the node from the nodes list. However, the node might have connections to other nodes, so we should remove those connections first.&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;using System;
using UnityEditor;
using UnityEngine;

public class Node
{
    public Rect rect;
    public string title;
    public bool isDragged;
    public bool isSelected;

    public ConnectionPoint inPoint;
    public ConnectionPoint outPoint;

    public GUIStyle style;
    public GUIStyle defaultNodeStyle;
    public GUIStyle selectedNodeStyle;

    public Action&amp;lt;Node&amp;gt; OnRemoveNode;

    public Node(Vector2 position, float width, float height, GUIStyle nodeStyle, GUIStyle selectedStyle, GUIStyle inPointStyle, GUIStyle outPointStyle, Action&amp;lt;ConnectionPoint&amp;gt; OnClickInPoint, Action&amp;lt;ConnectionPoint&amp;gt; OnClickOutPoint, Action&amp;lt;Node&amp;gt; OnClickRemoveNode)
    {
        rect = new Rect(position.x, position.y, width, height);
        style = nodeStyle;
        inPoint = new ConnectionPoint(this, ConnectionPointType.In, inPointStyle, OnClickInPoint);
        outPoint = new ConnectionPoint(this, ConnectionPointType.Out, outPointStyle, OnClickOutPoint);
        defaultNodeStyle = nodeStyle;
        selectedNodeStyle = selectedStyle;
        OnRemoveNode = OnClickRemoveNode;
    }

    public void Drag(Vector2 delta)
    {
        rect.position += delta;
    }

    public void Draw()
    {
        inPoint.Draw();
        outPoint.Draw();
        GUI.Box(rect, title, style);
    }

    public bool ProcessEvents(Event e)
    {
        switch (e.type)
        {
            case EventType.MouseDown:
                if (e.button == 0)
                {
                    if (rect.Contains(e.mousePosition))
                    {
                        isDragged = true;
                        GUI.changed = true;
                        isSelected = true;
                        style = selectedNodeStyle;
                    }
                    else
                    {
                        GUI.changed = true;
                        isSelected = false;
                        style = defaultNodeStyle;
                    }
                }

                if (e.button == 1 &amp;amp;amp;&amp;amp;amp; isSelected &amp;amp;amp;&amp;amp;amp; rect.Contains(e.mousePosition))
                {
                    ProcessContextMenu();
                    e.Use();
                }
                break;

            case EventType.MouseUp:
                isDragged = false;
                break;

            case EventType.MouseDrag:
                if (e.button == 0 &amp;amp;amp;&amp;amp;amp; isDragged)
                {
                    Drag(e.delta);
                    e.Use();
                    return true;
                }
                break;
        }

        return false;
    }

    private void ProcessContextMenu()
    {
        GenericMenu genericMenu = new GenericMenu();
        genericMenu.AddItem(new GUIContent(&amp;quot;Remove node&amp;quot;), false, OnClickRemoveNode);
        genericMenu.ShowAsContext();
    }

    private void OnClickRemoveNode()
    {
        if (OnRemoveNode != null)
        {
            OnRemoveNode(this);
        }
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;    private void OnClickAddNode(Vector2 mousePosition)
    {
        if (nodes == null)
        {
            nodes = new List&amp;lt;Node&amp;gt;();
        }

        nodes.Add(new Node(mousePosition, 200, 50, nodeStyle, selectedNodeStyle, inPointStyle, outPointStyle, OnClickInPoint, OnClickOutPoint, OnClickRemoveNode));
    }&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;    private void OnClickRemoveNode(Node node)
    {
        if (connections != null)
        {
            List&amp;lt;Connection&amp;gt; connectionsToRemove = new List&amp;lt;Connection&amp;gt;();

            for (int i = 0; i &amp;lt; connections.Count; i++)
            {
                if (connections[i].inPoint == node.inPoint || connections[i].outPoint == node.outPoint)
                {
                    connectionsToRemove.Add(connections[i]);
                }
            }

            for (int i = 0; i &amp;lt; connectionsToRemove.Count; i++)
            {
                connections.Remove(connectionsToRemove[i]);
            }

            connectionsToRemove = null;
        }

        nodes.Remove(node);
    }&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;final-touches&quot;&gt;Final Touches&lt;/h3&gt;

&lt;p&gt;The node editor is complete at this point, but it lacks some important features which would elevate the user experience:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A draggable canvas,&lt;/li&gt;
  &lt;li&gt;A bezier from selected connection point to the mouse position,&lt;/li&gt;
  &lt;li&gt;A grid in the background.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Making our canvas draggable is the easiest one, so let’s start with that. All we have to do is just apply mouse drag to every single node in the node list.&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;public class NodeBasedEditor : EditorWindow
{
    private List&amp;lt;Node&amp;gt; nodes;
    private List&amp;lt;Connection&amp;gt; connections;

    private GUIStyle nodeStyle;
    private GUIStyle selectedNodeStyle;
    private GUIStyle inPointStyle;
    private GUIStyle outPointStyle;

    private ConnectionPoint selectedInPoint;
    private ConnectionPoint selectedOutPoint;
    
    private Vector2 drag;

    ...&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;    private void ProcessEvents(Event e)
    {
        drag = Vector2.zero;

        switch (e.type)
        {
            case EventType.MouseDown:
                if (e.button == 0)
                {
                    ClearConnectionSelection();
                }

                if (e.button == 1)
                {
                    ProcessContextMenu(e.mousePosition);
                }
            break;

            case EventType.MouseDrag:
                if (e.button == 0)
                {
                    OnDrag(e.delta);
                }
            break;
        }
    }&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;    private void OnDrag(Vector2 delta)
    {
        drag = delta;

        if (nodes != null)
        {
            for (int i = 0; i &amp;lt; nodes.Count; i++)
            {
                nodes[i].Drag(delta);
            }
        }

        GUI.changed = true;
    }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next up, drawing the bezier from selected connection point to the mouse position. By drawing this bezier, we will let users know which connection point selected and how their connection will look like.&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;    private void OnGUI()
    {
        DrawNodes();
        DrawConnections();

        DrawConnectionLine(Event.current);

        ProcessNodeEvents(Event.current);
        ProcessEvents(Event.current);

        if (GUI.changed) Repaint();
    }&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;    private void DrawConnectionLine(Event e)
    {
        if (selectedInPoint != null &amp;amp;amp;&amp;amp;amp; selectedOutPoint == null)
        {
            Handles.DrawBezier(
                selectedInPoint.rect.center,
                e.mousePosition,
                selectedInPoint.rect.center + Vector2.left * 50f,
                e.mousePosition - Vector2.left * 50f,
                Color.white,
                null,
                2f
            );

            GUI.changed = true;
        }

        if (selectedOutPoint != null &amp;amp;amp;&amp;amp;amp; selectedInPoint == null)
        {
            Handles.DrawBezier(
                selectedOutPoint.rect.center,
                e.mousePosition,
                selectedOutPoint.rect.center - Vector2.left * 50f,
                e.mousePosition + Vector2.left * 50f,
                Color.white,
                null,
                2f
            );

            GUI.changed = true;
        }
    }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And finally, drawing the grid:&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;public class NodeBasedEditor : EditorWindow
{
    private List&amp;lt;Node&amp;gt; nodes;
    private List&amp;lt;Connection&amp;gt; connections;

    private GUIStyle nodeStyle;
    private GUIStyle selectedNodeStyle;
    private GUIStyle inPointStyle;
    private GUIStyle outPointStyle;

    private ConnectionPoint selectedInPoint;
    private ConnectionPoint selectedOutPoint;

    private Vector2 offset;
    private Vector2 drag;

    ...&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;    private void OnGUI()
    {
        DrawGrid(20, 0.2f, Color.gray);
        DrawGrid(100, 0.4f, Color.gray);

        DrawNodes();
        DrawConnections();

        DrawConnectionLine(Event.current);

        ProcessNodeEvents(Event.current);
        ProcessEvents(Event.current);

        if (GUI.changed) Repaint();
    }

    private void DrawGrid(float gridSpacing, float gridOpacity, Color gridColor)
    {
        int widthDivs = Mathf.CeilToInt(position.width / gridSpacing);
        int heightDivs = Mathf.CeilToInt(position.height / gridSpacing);

        Handles.BeginGUI();
        Handles.color = new Color(gridColor.r, gridColor.g, gridColor.b, gridOpacity);

        offset += drag * 0.5f;
        Vector3 newOffset = new Vector3(offset.x % gridSpacing, offset.y % gridSpacing, 0);

        for (int i = 0; i &amp;lt; widthDivs; i++)
        {
            Handles.DrawLine(new Vector3(gridSpacing * i, -gridSpacing, 0) + newOffset, new Vector3(gridSpacing * i, position.height, 0f) + newOffset);
        }

        for (int j = 0; j &amp;lt; heightDivs; j++)
        {
            Handles.DrawLine(new Vector3(-gridSpacing, gridSpacing * j, 0) + newOffset, new Vector3(position.width, gridSpacing * j, 0f) + newOffset);
        }

        Handles.color = Color.white;
        Handles.EndGUI();
    }&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;This concludes our tutorial and to be frank, our node editor looks like any first grade node editor you can find on the Asset Store. From this point on, you can work on it and create your own custom node editor. Here is a quest editor I built while working on a prototype:&lt;/p&gt;

&lt;div class=&quot;img-wrapper&quot;&gt;
    
        &lt;img src=&quot;/assets/img/sample-node-based-editor.png&quot; class=&quot;center&quot; alt=&quot;Sample Node Based Editor&quot; width=&quot;400px&quot; /&gt;
    
    &lt;div class=&quot;empty-caption&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;And as always, here is the script in full, below. Until next time.&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;using UnityEngine;
using UnityEditor;
using System.Collections.Generic;

public class NodeBasedEditor : EditorWindow
{
    private List&amp;lt;Node&amp;gt; nodes;
    private List&amp;lt;Connection&amp;gt; connections;

    private GUIStyle nodeStyle;
    private GUIStyle selectedNodeStyle;
    private GUIStyle inPointStyle;
    private GUIStyle outPointStyle;

    private ConnectionPoint selectedInPoint;
    private ConnectionPoint selectedOutPoint;

    private Vector2 offset;
    private Vector2 drag;

    [MenuItem(&amp;quot;Window/Node Based Editor&amp;quot;)]
    private static void OpenWindow()
    {
        NodeBasedEditor window = GetWindow&amp;lt;NodeBasedEditor&amp;gt;();
        window.titleContent = new GUIContent(&amp;quot;Node Based Editor&amp;quot;);
    }

    private void OnEnable()
    {
        nodeStyle = new GUIStyle();
        nodeStyle.normal.background = EditorGUIUtility.Load(&amp;quot;builtin skins/darkskin/images/node1.png&amp;quot;) as Texture2D;
        nodeStyle.border = new RectOffset(12, 12, 12, 12);

        selectedNodeStyle = new GUIStyle();
        selectedNodeStyle.normal.background = EditorGUIUtility.Load(&amp;quot;builtin skins/darkskin/images/node1 on.png&amp;quot;) as Texture2D;
        selectedNodeStyle.border = new RectOffset(12, 12, 12, 12);

        inPointStyle = new GUIStyle();
        inPointStyle.normal.background = EditorGUIUtility.Load(&amp;quot;builtin skins/darkskin/images/btn left.png&amp;quot;) as Texture2D;
        inPointStyle.active.background = EditorGUIUtility.Load(&amp;quot;builtin skins/darkskin/images/btn left on.png&amp;quot;) as Texture2D;
        inPointStyle.border = new RectOffset(4, 4, 12, 12);

        outPointStyle = new GUIStyle();
        outPointStyle.normal.background = EditorGUIUtility.Load(&amp;quot;builtin skins/darkskin/images/btn right.png&amp;quot;) as Texture2D;
        outPointStyle.active.background = EditorGUIUtility.Load(&amp;quot;builtin skins/darkskin/images/btn right on.png&amp;quot;) as Texture2D;
        outPointStyle.border = new RectOffset(4, 4, 12, 12);
    }

    private void OnGUI()
    {
        DrawGrid(20, 0.2f, Color.gray);
        DrawGrid(100, 0.4f, Color.gray);

        DrawNodes();
        DrawConnections();

        DrawConnectionLine(Event.current);

        ProcessNodeEvents(Event.current);
        ProcessEvents(Event.current);

        if (GUI.changed) Repaint();
    }

    private void DrawGrid(float gridSpacing, float gridOpacity, Color gridColor)
    {
        int widthDivs = Mathf.CeilToInt(position.width / gridSpacing);
        int heightDivs = Mathf.CeilToInt(position.height / gridSpacing);

        Handles.BeginGUI();
        Handles.color = new Color(gridColor.r, gridColor.g, gridColor.b, gridOpacity);

        offset += drag * 0.5f;
        Vector3 newOffset = new Vector3(offset.x % gridSpacing, offset.y % gridSpacing, 0);

        for (int i = 0; i &amp;lt; widthDivs; i++)
        {
            Handles.DrawLine(new Vector3(gridSpacing * i, -gridSpacing, 0) + newOffset, new Vector3(gridSpacing * i, position.height, 0f) + newOffset);
        }

        for (int j = 0; j &amp;lt; heightDivs; j++)
        {
            Handles.DrawLine(new Vector3(-gridSpacing, gridSpacing * j, 0) + newOffset, new Vector3(position.width, gridSpacing * j, 0f) + newOffset);
        }

        Handles.color = Color.white;
        Handles.EndGUI();
    }

    private void DrawNodes()
    {
        if (nodes != null)
        {
            for (int i = 0; i &amp;lt; nodes.Count; i++)
            {
                nodes[i].Draw();
            }
        }
    }

    private void DrawConnections()
    {
        if (connections != null)
        {
            for (int i = 0; i &amp;lt; connections.Count; i++)
            {
                connections[i].Draw();
            } 
        }
    }

    private void ProcessEvents(Event e)
    {
        drag = Vector2.zero;

        switch (e.type)
        {
            case EventType.MouseDown:
                if (e.button == 0)
                {
                    ClearConnectionSelection();
                }

                if (e.button == 1)
                {
                    ProcessContextMenu(e.mousePosition);
                }
            break;

            case EventType.MouseDrag:
                if (e.button == 0)
                {
                    OnDrag(e.delta);
                }
            break;
        }
    }

    private void ProcessNodeEvents(Event e)
    {
        if (nodes != null)
        {
            for (int i = nodes.Count - 1; i &amp;gt;= 0; i--)
            {
                bool guiChanged = nodes[i].ProcessEvents(e);

                if (guiChanged)
                {
                    GUI.changed = true;
                }
            }
        }
    }

    private void DrawConnectionLine(Event e)
    {
        if (selectedInPoint != null &amp;amp;amp;&amp;amp;amp; selectedOutPoint == null)
        {
            Handles.DrawBezier(
                selectedInPoint.rect.center,
                e.mousePosition,
                selectedInPoint.rect.center + Vector2.left * 50f,
                e.mousePosition - Vector2.left * 50f,
                Color.white,
                null,
                2f
            );

            GUI.changed = true;
        }

        if (selectedOutPoint != null &amp;amp;amp;&amp;amp;amp; selectedInPoint == null)
        {
            Handles.DrawBezier(
                selectedOutPoint.rect.center,
                e.mousePosition,
                selectedOutPoint.rect.center - Vector2.left * 50f,
                e.mousePosition + Vector2.left * 50f,
                Color.white,
                null,
                2f
            );

            GUI.changed = true;
        }
    }

    private void ProcessContextMenu(Vector2 mousePosition)
    {
        GenericMenu genericMenu = new GenericMenu();
        genericMenu.AddItem(new GUIContent(&amp;quot;Add node&amp;quot;), false, () =&amp;gt; OnClickAddNode(mousePosition)); 
        genericMenu.ShowAsContext();
    }

    private void OnDrag(Vector2 delta)
    {
        drag = delta;

        if (nodes != null)
        {
            for (int i = 0; i &amp;lt; nodes.Count; i++)
            {
                nodes[i].Drag(delta);
            }
        }

        GUI.changed = true;
    }

    private void OnClickAddNode(Vector2 mousePosition)
    {
        if (nodes == null)
        {
            nodes = new List&amp;lt;Node&amp;gt;();
        }

        nodes.Add(new Node(mousePosition, 200, 50, nodeStyle, selectedNodeStyle, inPointStyle, outPointStyle, OnClickInPoint, OnClickOutPoint, OnClickRemoveNode));
    }

    private void OnClickInPoint(ConnectionPoint inPoint)
    {
        selectedInPoint = inPoint;

        if (selectedOutPoint != null)
        {
            if (selectedOutPoint.node != selectedInPoint.node)
            {
                CreateConnection();
                ClearConnectionSelection(); 
            }
            else
            {
                ClearConnectionSelection();
            }
        }
    }

    private void OnClickOutPoint(ConnectionPoint outPoint)
    {
        selectedOutPoint = outPoint;

        if (selectedInPoint != null)
        {
            if (selectedOutPoint.node != selectedInPoint.node)
            {
                CreateConnection();
                ClearConnectionSelection();
            }
            else
            {
                ClearConnectionSelection();
            }
        }
    }

    private void OnClickRemoveNode(Node node)
    {
        if (connections != null)
        {
            List&amp;lt;Connection&amp;gt; connectionsToRemove = new List&amp;lt;Connection&amp;gt;();

            for (int i = 0; i &amp;lt; connections.Count; i++)
            {
                if (connections[i].inPoint == node.inPoint || connections[i].outPoint == node.outPoint)
                {
                    connectionsToRemove.Add(connections[i]);
                }
            }

            for (int i = 0; i &amp;lt; connectionsToRemove.Count; i++)
            {
                connections.Remove(connectionsToRemove[i]);
            }

            connectionsToRemove = null;
        }

        nodes.Remove(node);
    }

    private void OnClickRemoveConnection(Connection connection)
    {
        connections.Remove(connection);
    }

    private void CreateConnection()
    {
        if (connections == null)
        {
            connections = new List&amp;lt;Connection&amp;gt;();
        }

        connections.Add(new Connection(selectedInPoint, selectedOutPoint, OnClickRemoveConnection));
    }

    private void ClearConnectionSelection()
    {
        selectedInPoint = null;
        selectedOutPoint = null;
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;using System;
using UnityEditor;
using UnityEngine;

public class Node
{
    public Rect rect;
    public string title;
    public bool isDragged;
    public bool isSelected;

    public ConnectionPoint inPoint;
    public ConnectionPoint outPoint;

    public GUIStyle style;
    public GUIStyle defaultNodeStyle;
    public GUIStyle selectedNodeStyle;

    public Action&amp;lt;Node&amp;gt; OnRemoveNode;

    public Node(Vector2 position, float width, float height, GUIStyle nodeStyle, GUIStyle selectedStyle, GUIStyle inPointStyle, GUIStyle outPointStyle, Action&amp;lt;ConnectionPoint&amp;gt; OnClickInPoint, Action&amp;lt;ConnectionPoint&amp;gt; OnClickOutPoint, Action&amp;lt;Node&amp;gt; OnClickRemoveNode)
    {
        rect = new Rect(position.x, position.y, width, height);
        style = nodeStyle;
        inPoint = new ConnectionPoint(this, ConnectionPointType.In, inPointStyle, OnClickInPoint);
        outPoint = new ConnectionPoint(this, ConnectionPointType.Out, outPointStyle, OnClickOutPoint);
        defaultNodeStyle = nodeStyle;
        selectedNodeStyle = selectedStyle;
        OnRemoveNode = OnClickRemoveNode;
    }

    public void Drag(Vector2 delta)
    {
        rect.position += delta;
    }

    public void Draw()
    {
        inPoint.Draw();
        outPoint.Draw();
        GUI.Box(rect, title, style);
    }

    public bool ProcessEvents(Event e)
    {
        switch (e.type)
        {
            case EventType.MouseDown:
                if (e.button == 0)
                {
                    if (rect.Contains(e.mousePosition))
                    {
                        isDragged = true;
                        GUI.changed = true;
                        isSelected = true;
                        style = selectedNodeStyle;
                    }
                    else
                    {
                        GUI.changed = true;
                        isSelected = false;
                        style = defaultNodeStyle;
                    }
                }

                if (e.button == 1 &amp;amp;amp;&amp;amp;amp; isSelected &amp;amp;amp;&amp;amp;amp; rect.Contains(e.mousePosition))
                {
                    ProcessContextMenu();
                    e.Use();
                }
                break;

            case EventType.MouseUp:
                isDragged = false;
                break;

            case EventType.MouseDrag:
                if (e.button == 0 &amp;amp;amp;&amp;amp;amp; isDragged)
                {
                    Drag(e.delta);
                    e.Use();
                    return true;
                }
                break;
        }

        return false;
    }

    private void ProcessContextMenu()
    {
        GenericMenu genericMenu = new GenericMenu();
        genericMenu.AddItem(new GUIContent(&amp;quot;Remove node&amp;quot;), false, OnClickRemoveNode);
        genericMenu.ShowAsContext();
    }

    private void OnClickRemoveNode()
    {
        if (OnRemoveNode != null)
        {
            OnRemoveNode(this);
        }
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;using System;
using UnityEditor;
using UnityEngine;

public class Connection
{
    public ConnectionPoint inPoint;
    public ConnectionPoint outPoint;
    public Action&amp;lt;Connection&amp;gt; OnClickRemoveConnection;

    public Connection(ConnectionPoint inPoint, ConnectionPoint outPoint, Action&amp;lt;Connection&amp;gt; OnClickRemoveConnection)
    {
        this.inPoint = inPoint;
        this.outPoint = outPoint;
        this.OnClickRemoveConnection = OnClickRemoveConnection;
    }

    public void Draw()
    {
        Handles.DrawBezier(
            inPoint.rect.center,
            outPoint.rect.center,
            inPoint.rect.center + Vector2.left * 50f,
            outPoint.rect.center - Vector2.left * 50f,
            Color.white,
            null,
            2f
        );

        if (Handles.Button((inPoint.rect.center + outPoint.rect.center) * 0.5f, Quaternion.identity, 4, 8, Handles.RectangleCap))
        {
            if (OnClickRemoveConnection != null)
            {
                OnClickRemoveConnection(this);
            }
        }
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot;&gt;&lt;code&gt;using System;
using UnityEngine;

public enum ConnectionPointType { In, Out }

public class ConnectionPoint
{
    public Rect rect;

    public ConnectionPointType type;

    public Node node;

    public GUIStyle style;

    public Action&amp;lt;ConnectionPoint&amp;gt; OnClickConnectionPoint;

    public ConnectionPoint(Node node, ConnectionPointType type, GUIStyle style, Action&amp;lt;ConnectionPoint&amp;gt; OnClickConnectionPoint)
    {
        this.node = node;
        this.type = type;
        this.style = style;
        this.OnClickConnectionPoint = OnClickConnectionPoint;
        rect = new Rect(0, 0, 10f, 20f);
    }

    public void Draw()
    {
        rect.y = node.rect.y + (node.rect.height * 0.5f) - rect.height * 0.5f;

        switch (type)
        {
            case ConnectionPointType.In:
            rect.x = node.rect.x - rect.width + 8f;
            break;

            case ConnectionPointType.Out:
            rect.x = node.rect.x + node.rect.width - 8f;
            break;
        }

        if (GUI.Button(rect, &amp;quot;&amp;quot;, style))
        {
            if (OnClickConnectionPoint != null)
            {
                OnClickConnectionPoint(this);
            }
        }
    }
}&lt;/code&gt;&lt;/pre&gt;</content><author><name>Oguz Konya</name></author><summary type="html">Node based editors are frequently used in game engines; Unity has Animator window, Unreal Engine has blueprint system, some other game engines have dialogue systems. In this blog post, we will create our own node based editor in Unity. It’s going to be simple node editor that you’ll be able to improve upon later (see the below image for an example). I am going to assume that you are already familiar with editor scripting, but if you are not, please take your time to have a look at this post and this post.</summary></entry><entry><title type="html">Creating a Clone of Unity’s Console Window</title><link href="https://oguzkonya.github.io/creating-clone-unitys-console-window/" rel="alternate" type="text/html" title="Creating a Clone of Unity's Console Window" /><published>2019-08-08T00:00:00+00:00</published><updated>2019-08-08T00:00:00+00:00</updated><id>https://oguzkonya.github.io/creating-clone-unitys-console-window</id><content type="html" xml:base="https://oguzkonya.github.io/creating-clone-unitys-console-window/">&lt;p&gt;In our last &lt;a href=&quot;/creating-editor-windows-in-unity/&quot;&gt;post&lt;/a&gt; we created a Unity window and added two resizable panels. In this post, we will improve upon it and make it a clone of Unity’s console window. This post is going to be a little bit longer, so I will omit the previously written code, but the final version will still be available in full at the end.&lt;/p&gt;

&lt;p&gt;Before we start coding, let’s examine the console window and see what we should add.&lt;/p&gt;

&lt;div class=&quot;img-wrapper&quot;&gt;
    
        &lt;img src=&quot;/assets/img/unity-console-window.png&quot; class=&quot;center&quot; alt=&quot;Unity's console window&quot; width=&quot;400px&quot; /&gt;
    
    &lt;div class=&quot;empty-caption&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;The window starts with a menu bar (1) which has one button and six toggles. The button and three toggles are aligned to left, and the remaining toggles are aligned to right. The button clears the window, while toggles turn on and off specific options. Then there is a scroll view (2) that contains clickable boxes with icons and text. Boxes change color when you click on them, and their content is displayed in the bottom panel (3), a text area which is not editable but selectable.&lt;/p&gt;

&lt;p&gt;Alright then, we can start. But, before we do, I would like to fix a tiny issue from the previous post’s code. I left a magic number as the height of the resizer area, and I would like to convert it to a proper variable:&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot; data-start=&quot;6&quot; data-line=&quot;13&quot; data-filename=&quot;ResizablePanels.cs&quot;&gt;&lt;code&gt;    private Rect upperPanel;
    private Rect lowerPanel; 
    private Rect resizer; 

    private float sizeRatio = 0.5f; 
    private bool isResizing; 

    private float resizerHeight = 5f; 

    private GUIStyle resizerStyle;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And, further down the code, once again replace the magic number with the variable:&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot; data-start=&quot;50&quot; data-line=&quot;52,61,63&quot;&gt;&lt;code&gt;    private void DrawLowerPanel()
    {
        lowerPanel = new Rect(0, (position.height * sizeRatio) + resizerHeight, position.width, (position.height * (1 - sizeRatio)) - resizerHeight);

        GUILayout.BeginArea(lowerPanel);
        GUILayout.Label(&amp;quot;Lower Panel&amp;quot;);
        GUILayout.EndArea();
    }

    private void DrawResizer()
    {
        resizer = new Rect(0, (position.height * sizeRatio) - resizerHeight, position.width, resizerHeight * 2);

        GUILayout.BeginArea(new Rect(resizer.position + (Vector2.up * resizerHeight), new Vector2(position.width, 2)), resizerStyle);
        GUILayout.EndArea();

        EditorGUIUtility.AddCursorRect(resizer, MouseCursor.ResizeVertical);
    }&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;menu-bar&quot;&gt;Menu Bar&lt;/h3&gt;

&lt;p&gt;Now we can start adding our menu bar. We will draw this bar just as we drew other panels: by feeding &lt;code class=&quot;highlighter-rouge&quot;&gt;GUILayout.BeginArea()&lt;/code&gt; a rectangle which would define its position and size (basically, its area). I am going to steal this area  from the upper panel, so that we won’t have to change other panels’ positions or heights. You can make this bar as tall as you would like, but since we are cloning Unity’s console window, we should stick to default and make it 20 pixels in height. Also, please note that this time, &lt;code class=&quot;highlighter-rouge&quot;&gt;GUILayout.BeginArea()&lt;/code&gt; takes a second parameter: &lt;code class=&quot;highlighter-rouge&quot;&gt;EditorStyles.toolbar&lt;/code&gt;. As the name suggests, this parameter tells Unity to draw this area in toolbar style. &lt;code class=&quot;highlighter-rouge&quot;&gt;EditorStyles&lt;/code&gt; has many other options to choose from which affects how the GUI elements are displayed, so I would suggest checking them out and see Unity team used them in their own editor windows.&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot; data-start=&quot;6&quot; data-line=&quot;9,15&quot;&gt;&lt;code&gt;    private Rect upperPanel;
    private Rect lowerPanel; 
    private Rect resizer; 
    private Rect menuBar;

    private float sizeRatio = 0.5f; 
    private bool isResizing; 

    private float resizerHeight = 5f; 
    private float menuBarHeight = 20f;

    private GUIStyle resizerStyle;&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot; data-start=&quot;32&quot; data-line=&quot;34,44-50,54&quot;&gt;&lt;code&gt;    private void OnGUI()
    {
        DrawMenuBar();
        DrawUpperPanel();
        DrawLowerPanel();
        DrawResizer();

        ProcessEvents(Event.current);
        
        if (GUI.changed) Repaint();
    }

    private void DrawMenuBar()
    {
        menuBar = new Rect(0, 0, position.width, menuBarHeight);

        GUILayout.BeginArea(menuBar, EditorStyles.toolbar);
        GUILayout.EndArea();
    }

    private void DrawUpperPanel()
    {
        upperPanel = new Rect(0, menuBarHeight, position.width, (position.height * sizeRatio) - menuBarHeight);

        GUILayout.BeginArea(upperPanel);
        GUILayout.Label(&amp;quot;Upper Panel&amp;quot;);
        GUILayout.EndArea();
    }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK, we are ready to add our buttons and toggles. I could have added them in the code above, but there are a couple of new concepts that I should explain beforehand. First of all, there is &lt;code class=&quot;highlighter-rouge&quot;&gt;GUILayout.BeginHorizontal()&lt;/code&gt;. You see, &lt;code class=&quot;highlighter-rouge&quot;&gt;GUILayout&lt;/code&gt;, as the name suggests, lays out the GUI automatically &lt;strong&gt;vertically&lt;/strong&gt;. However, a toolbar is laid out horizontally, so we need to use &lt;code class=&quot;highlighter-rouge&quot;&gt;GUILayout.BeginHorizontal()&lt;/code&gt; and then use &lt;code class=&quot;highlighter-rouge&quot;&gt;GUILayout.EndHorizontal()&lt;/code&gt; so that Unity stops horizontal layout and continues automatic vertical layout. Then, there is &lt;code class=&quot;highlighter-rouge&quot;&gt;GUILayout.FlexibleSpace()&lt;/code&gt; which acts like a spring and pushes other UI elements to the edges of its container by filling the space between them. On the other hand, &lt;code class=&quot;highlighter-rouge&quot;&gt;GUILayout.Space(int)&lt;/code&gt; creates just the amount of space you need. &lt;code class=&quot;highlighter-rouge&quot;&gt;GUILayout.Button()&lt;/code&gt; returns true when it is clicked and &lt;code class=&quot;highlighter-rouge&quot;&gt;GUILayout.Toggle()&lt;/code&gt; returns a boolean depending on the status of the toggle: true when it is on and false when it is off.&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot; data-start=&quot;14&quot; data-line=&quot;17-22&quot;&gt;&lt;code&gt;    private float resizerHeight = 5f;
    private float menuBarHeight = 20f;

    private bool collapse = false;
    private bool clearOnPlay = false;
    private bool errorPause = false;
    private bool showLog = false;
    private bool showWarnings = false;
    private bool showErrors = false;

    private GUIStyle resizerStyle;&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot; data-start=&quot;51&quot; data-line=&quot;56-71&quot;&gt;&lt;code&gt;    private void DrawMenuBar()
    {
        menuBar = new Rect(0, 0, position.width, menuBarHeight);

        GUILayout.BeginArea(menuBar, EditorStyles.toolbar);
        GUILayout.BeginHorizontal();

        GUILayout.Button(new GUIContent(&amp;quot;Clear&amp;quot;), EditorStyles.toolbarButton, GUILayout.Width(35));
        GUILayout.Space(5);

        collapse = GUILayout.Toggle(collapse, new GUIContent(&amp;quot;Collapse&amp;quot;), EditorStyles.toolbarButton, GUILayout.Width(50));
        clearOnPlay = GUILayout.Toggle(clearOnPlay, new GUIContent(&amp;quot;Clear On Play&amp;quot;), EditorStyles.toolbarButton, GUILayout.Width(70));
        errorPause = GUILayout.Toggle(errorPause, new GUIContent(&amp;quot;Error Pause&amp;quot;), EditorStyles.toolbarButton, GUILayout.Width(60));

        GUILayout.FlexibleSpace();

        showLog = GUILayout.Toggle(showLog, new GUIContent(&amp;quot;L&amp;quot;), EditorStyles.toolbarButton, GUILayout.Width(30));
        showWarnings = GUILayout.Toggle(showWarnings, new GUIContent(&amp;quot;W&amp;quot;), EditorStyles.toolbarButton, GUILayout.Width(30));
        showErrors = GUILayout.Toggle(showErrors, new GUIContent(&amp;quot;E&amp;quot;), EditorStyles.toolbarButton, GUILayout.Width(30));

        GUILayout.EndHorizontal();
        GUILayout.EndArea();
    }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It looks pretty good, but the toggles on the right are missing their icons. Adding icons and textures to GUI elements is rather easy, but Unity lacks the documentation on how to do it. Here’s a piece of information you probably can’t find on the internet: Unity uses &lt;code class=&quot;highlighter-rouge&quot;&gt;EditorGUIUtility.Load(string)&lt;/code&gt; to load editor resources and &lt;a href=&quot;https://gist.github.com/masa795/5797164&quot;&gt;this&lt;/a&gt; piece of script lists some of the default Unity editor textures (all the icons). I checked the list and found the icons used in the console editor, so let’s add them into our own clone.&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot; data-start=&quot;24&quot; data-line=&quot;26-31&quot;&gt;&lt;code&gt;    private GUIStyle resizerStyle;

    private Texture2D errorIcon;
    private Texture2D errorIconSmall;
    private Texture2D warningIcon;
    private Texture2D warningIconSmall;
    private Texture2D infoIcon;
    private Texture2D infoIconSmall;&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot; data-start=&quot;40&quot; data-line=&quot;42-48&quot;&gt;&lt;code&gt;    private void OnEnable()
    {
        errorIcon = EditorGUIUtility.Load(&amp;quot;icons/console.erroricon.png&amp;quot;) as Texture2D;
        warningIcon = EditorGUIUtility.Load(&amp;quot;icons/console.warnicon.png&amp;quot;) as Texture2D;
        infoIcon = EditorGUIUtility.Load(&amp;quot;icons/console.infoicon.png&amp;quot;) as Texture2D;

        errorIconSmall = EditorGUIUtility.Load(&amp;quot;icons/console.erroricon.sml.png&amp;quot;) as Texture2D;
        warningIconSmall = EditorGUIUtility.Load(&amp;quot;icons/console.warnicon.sml.png&amp;quot;) as Texture2D;
        infoIconSmall = EditorGUIUtility.Load(&amp;quot;icons/console.infoicon.sml.png&amp;quot;) as Texture2D;

        resizerStyle = new GUIStyle();
        resizerStyle.normal.background = EditorGUIUtility.Load(&amp;quot;icons/d_AvatarBlendBackground.png&amp;quot;) as Texture2D;
    }&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot; data-start=&quot;66&quot; data-line=&quot;82-84&quot;&gt;&lt;code&gt;    private void DrawMenuBar()
    {
        menuBar = new Rect(0, 0, position.width, menuBarHeight);

        GUILayout.BeginArea(menuBar, EditorStyles.toolbar);
        GUILayout.BeginHorizontal();

        GUILayout.Button(new GUIContent(&amp;quot;Clear&amp;quot;), EditorStyles.toolbarButton, GUILayout.Width(35));
        GUILayout.Space(5);

        collapse = GUILayout.Toggle(collapse, new GUIContent(&amp;quot;Collapse&amp;quot;), EditorStyles.toolbarButton, GUILayout.Width(50));
        clearOnPlay = GUILayout.Toggle(clearOnPlay, new GUIContent(&amp;quot;Clear On Play&amp;quot;), EditorStyles.toolbarButton, GUILayout.Width(70));
        errorPause = GUILayout.Toggle(errorPause, new GUIContent(&amp;quot;Error Pause&amp;quot;), EditorStyles.toolbarButton, GUILayout.Width(60));

        GUILayout.FlexibleSpace();

        showLog = GUILayout.Toggle(showLog, new GUIContent(&amp;quot;L&amp;quot;, infoIconSmall), EditorStyles.toolbarButton, GUILayout.Width(30));
        showWarnings = GUILayout.Toggle(showWarnings, new GUIContent(&amp;quot;W&amp;quot;, warningIconSmall), EditorStyles.toolbarButton, GUILayout.Width(30));
        showErrors = GUILayout.Toggle(showErrors, new GUIContent(&amp;quot;E&amp;quot;, errorIconSmall), EditorStyles.toolbarButton, GUILayout.Width(30));

        GUILayout.EndHorizontal();
        GUILayout.EndArea();
    }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It definitely looks like a clone of the console window, right? :)&lt;/p&gt;

&lt;div class=&quot;img-wrapper&quot;&gt;
    
        &lt;img src=&quot;/assets/img/resizable-panels.png&quot; class=&quot;center&quot; alt=&quot;Resizable Panels&quot; width=&quot;400px&quot; /&gt;
    
    &lt;div class=&quot;empty-caption&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;h3 id=&quot;upper-panel&quot;&gt;Upper Panel&lt;/h3&gt;

&lt;p&gt;Let’s move on to the upper panel. This panel should be scrollable, because it could contain more content than it can display. Here is another new concept: &lt;code class=&quot;highlighter-rouge&quot;&gt;GUILayout.BeginScrollView(Vector2 scroll)&lt;/code&gt; creates a scroll view in the area it is defined. All the GUI elements between &lt;code class=&quot;highlighter-rouge&quot;&gt;GUILayout.BeginScrollView(Vector2 scroll)&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;GUILayout.EndScrollView()&lt;/code&gt; will be displayed in this scroll area.&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot; data-start=&quot;24&quot; data-line=&quot;24&quot;&gt;&lt;code&gt;    private Vector2 upperPanelScroll;

    private GUIStyle resizerStyle;

    private Texture2D errorIcon;
    private Texture2D errorIconSmall;
    private Texture2D warningIcon;
    private Texture2D warningIconSmall;
    private Texture2D infoIcon;
    private Texture2D infoIconSmall;&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot; data-start=&quot;92&quot; data-line=&quot;97-99&quot;&gt;&lt;code&gt;    private void DrawUpperPanel()
    {
        upperPanel = new Rect(0, menuBarHeight, position.width, (position.height * sizeRatio) - menuBarHeight);

        GUILayout.BeginArea(upperPanel);
        upperPanelScroll = GUILayout.BeginScrollView(upperPanelScroll);

        GUILayout.EndScrollView();
        GUILayout.EndArea();
    }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unity’s console window displays boxes in this panel, so will we. However, it is not going to be one liner, because we need to know what kind of content needs to be displayed (info, warning or error), and what its index number is (so that we can do a zebra effect on the boxes). For these reasons, it is going to be a little more work than we did previously. First of all, we need an &lt;strong&gt;enum&lt;/strong&gt; for the content type of the box, which fortunately exists: &lt;code class=&quot;highlighter-rouge&quot;&gt;LogType&lt;/code&gt;. Then, we should create a method for drawing boxes. This method will draw a box, add an icon to the left of the content based on its type, set the background color to a lighter or darker color based on its index (lighter if the index is odd, darker if the index is even) and then display a text.&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot; data-start=&quot;24&quot; data-line=&quot;27,29-32&quot;&gt;&lt;code&gt;    private Vector2 upperPanelScroll;

    private GUIStyle resizerStyle;
    private GUIStyle boxStyle;

    private Texture2D boxBgOdd;
    private Texture2D boxBgEven;
    private Texture2D boxBgSelected;
    private Texture2D icon;
    private Texture2D errorIcon;
    private Texture2D errorIconSmall;
    private Texture2D warningIcon;
    private Texture2D warningIconSmall;
    private Texture2D infoIcon;
    private Texture2D infoIconSmall;&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot; data-start=&quot;47&quot; data-line=&quot;60-65&quot;&gt;&lt;code&gt;    private void OnEnable()
    {
        errorIcon = EditorGUIUtility.Load(&amp;quot;icons/console.erroricon.png&amp;quot;) as Texture2D;
        warningIcon = EditorGUIUtility.Load(&amp;quot;icons/console.warnicon.png&amp;quot;) as Texture2D;
        infoIcon = EditorGUIUtility.Load(&amp;quot;icons/console.infoicon.png&amp;quot;) as Texture2D;

        errorIconSmall = EditorGUIUtility.Load(&amp;quot;icons/console.erroricon.sml.png&amp;quot;) as Texture2D;
        warningIconSmall = EditorGUIUtility.Load(&amp;quot;icons/console.warnicon.sml.png&amp;quot;) as Texture2D;
        infoIconSmall = EditorGUIUtility.Load(&amp;quot;icons/console.infoicon.sml.png&amp;quot;) as Texture2D;

        resizerStyle = new GUIStyle();
        resizerStyle.normal.background = EditorGUIUtility.Load(&amp;quot;icons/d_AvatarBlendBackground.png&amp;quot;) as Texture2D;

        boxStyle = new GUIStyle();
        boxStyle.normal.textColor = new Color(0.7f, 0.7f, 0.7f);
        
        boxBgOdd = EditorGUIUtility.Load(&amp;quot;builtin skins/darkskin/images/cn entrybackodd.png&amp;quot;) as Texture2D;
        boxBgEven = EditorGUIUtility.Load(&amp;quot;builtin skins/darkskin/images/cnentrybackeven.png&amp;quot;) as Texture2D;
        boxBgSelected = EditorGUIUtility.Load(&amp;quot;builtin skins/darkskin/images/menuitemhover.png&amp;quot;) as Texture2D;
    }&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot; data-start=&quot;124&quot; data-line=&quot;134-162&quot;&gt;&lt;code&gt;    private void DrawResizer()
    {
        resizer = new Rect(0, (position.height * sizeRatio) - resizerHeight, position.width, resizerHeight * 2);

        GUILayout.BeginArea(new Rect(resizer.position + (Vector2.up * resizerHeight), new Vector2(position.width, 2)), resizerStyle);
        GUILayout.EndArea();

        EditorGUIUtility.AddCursorRect(resizer, MouseCursor.ResizeVertical);
    }

    private bool DrawBox(string content, BoxType boxType, bool isOdd, bool isSelected)
    {
        if (isSelected)
        {
            boxStyle.normal.background = boxBgSelected;
        }
        else 
        {
            if (isOdd)
            {
                boxStyle.normal.background = boxBgOdd;
            }
            else
            {
                boxStyle.normal.background = boxBgEven;
            }
        }

        switch (boxType)
        {
            case LogType.Error: icon = errorIcon; break;
            case LogType.Exception: icon = errorIcon; break;
            case LogType.Assert: icon = errorIcon; break;
            case LogType.Warning: icon = warningIcon; break;
            case LogType.Log: icon = infoIcon; break;
        }

        return GUILayout.Button(new GUIContent(content, icon), boxStyle, GUILayout.ExpandWidth(true), GUILayout.Height(30));
    }

    private void ProcessEvents(Event e)
    {
        ...&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can use &lt;code class=&quot;highlighter-rouge&quot;&gt;DrawBox()&lt;/code&gt; method in &lt;code class=&quot;highlighter-rouge&quot;&gt;DrawUpperPanel()&lt;/code&gt; to actually display some content:&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot; data-start=&quot;104&quot; data-line=&quot;111-115&quot;&gt;&lt;code&gt;    private void DrawUpperPanel()
    {
        upperPanel = new Rect(0, menuBarHeight, position.width, (position.height * sizeRatio) - menuBarHeight);

        GUILayout.BeginArea(upperPanel);
        upperPanelScroll = GUILayout.BeginScrollView(upperPanelScroll);

        DrawBox(&amp;quot;Hello, World!&amp;quot;, LogType.Log, true);
        DrawBox(&amp;quot;ResizablePanels here!&amp;quot;, LogType.Log, false);
        DrawBox(&amp;quot;How do I look?&amp;quot;, LogType.Warning, true);
        DrawBox(&amp;quot;The lower panel doesn&amp;#39;t seem to be working.&amp;quot;, LogType.Error, false);
        DrawBox(&amp;quot;You should start working on that.&amp;quot;, LogType.Warning, true);

        GUILayout.EndScrollView();
        GUILayout.EndArea();
    }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the result is a scrollable panel with a zebra effect and icons!:&lt;/p&gt;

&lt;div class=&quot;img-wrapper&quot;&gt;
    
        &lt;img src=&quot;/assets/img/resizable-panels-working-upper-panel-1.png&quot; class=&quot;center&quot; alt=&quot;Resizable Panels&quot; width=&quot;400px&quot; /&gt;
    
    &lt;div class=&quot;empty-caption&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;h3 id=&quot;lower-panel&quot;&gt;Lower Panel&lt;/h3&gt;

&lt;p&gt;Up next is the lower panel. All this panel does is to display a message, so we will just add a scroll view and a text area.&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot; data-start=&quot;24&quot; data-line=&quot;25-29&quot;&gt;&lt;code&gt;    private Vector2 upperPanelScroll;
    private Vector2 lowerPanelScroll;

    private GUIStyle resizerStyle;
    private GUIStyle boxStyle;
    private GUIStyle textAreaStyle;&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot; data-start=&quot;49&quot; data-line=&quot;69-71&quot;&gt;&lt;code&gt;    private void OnEnable()
    {
        errorIcon = EditorGUIUtility.Load(&amp;quot;icons/console.erroricon.png&amp;quot;) as Texture2D;
        warningIcon = EditorGUIUtility.Load(&amp;quot;icons/console.warnicon.png&amp;quot;) as Texture2D;
        infoIcon = EditorGUIUtility.Load(&amp;quot;icons/console.infoicon.png&amp;quot;) as Texture2D;

        errorIconSmall = EditorGUIUtility.Load(&amp;quot;icons/console.erroricon.sml.png&amp;quot;) as Texture2D;
        warningIconSmall = EditorGUIUtility.Load(&amp;quot;icons/console.warnicon.sml.png&amp;quot;) as Texture2D;
        infoIconSmall = EditorGUIUtility.Load(&amp;quot;icons/console.infoicon.sml.png&amp;quot;) as Texture2D;

        resizerStyle = new GUIStyle();
        resizerStyle.normal.background = EditorGUIUtility.Load(&amp;quot;icons/d_AvatarBlendBackground.png&amp;quot;) as Texture2D;

        boxStyle = new GUIStyle();
        boxStyle.normal.textColor = new Color(0.7f, 0.7f, 0.7f);

        boxBgOdd = EditorGUIUtility.Load(&amp;quot;builtin skins/darkskin/images/cn entrybackodd.png&amp;quot;) as Texture2D;
        boxBgEven = EditorGUIUtility.Load(&amp;quot;builtin skins/darkskin/images/cnentrybackeven.png&amp;quot;) as Texture2D;
        boxBgSelected = EditorGUIUtility.Load(&amp;quot;builtin skins/darkskin/images/menuitemhover.png&amp;quot;) as Texture2D;

        textAreaStyle = new GUIStyle();
        textAreaStyle.normal.textColor = new Color(0.9f, 0.9f, 0.9f);
        textAreaStyle.normal.background = EditorGUIUtility.Load(&amp;quot;builtin skins/darkskin/images/projectbrowsericonareabg.png&amp;quot;) as Texture2D;
    }&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot; data-start=&quot;127&quot; data-line=&quot;132-136&quot;&gt;&lt;code&gt;    private void DrawLowerPanel()
    {
        lowerPanel = new Rect(0, (position.height * sizeRatio) + resizerHeight, position.width, (position.height * (1 - sizeRatio)) - resizerHeight);

        GUILayout.BeginArea(lowerPanel);
        lowerPanelScroll = GUILayout.BeginScrollView(lowerPanelScroll);

        GUILayout.TextArea(&amp;quot;It is working now!&amp;quot;, textAreaStyle);

        GUILayout.EndScrollView();
        GUILayout.EndArea();
    }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It looks great!&lt;/p&gt;

&lt;div class=&quot;img-wrapper&quot;&gt;
    
        &lt;img src=&quot;/assets/img/resizable-panels-working-lower-panel-1.png&quot; class=&quot;center&quot; alt=&quot;Resizable Panels&quot; width=&quot;400px&quot; /&gt;
    
    &lt;div class=&quot;empty-caption&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;h3 id=&quot;adding-interaction&quot;&gt;Adding Interaction&lt;/h3&gt;

&lt;p&gt;Yes, our window looks good, but it doesn’t do anything useful right now. Since this is a console window clone, I would like it to receive log messages from Unity’s own &lt;code class=&quot;highlighter-rouge&quot;&gt;Debug&lt;/code&gt; class and display them in a similar manner. A log contains some data, such as a log string, a stack trace and a type, hence we need a class for it. We will be keeping the instances of this class in a list and a reference to the selected log. When we modify the upper and lower panel code, our window will start behaving exactly like the console window.&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot; data-start=&quot;209&quot; data-line=&quot;209-223&quot;&gt;&lt;code&gt;public class Log
{
    public bool isSelected;
    public string info;
    public string message;
    public LogType type;

    public Log(bool isSelected, string info, string message, LogType type)
    {
        this.isSelected = isSelected;
        this.info = info;
        this.message = message;
        this.type = type;
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot; data-line=&quot;3&quot;&gt;&lt;code&gt;using UnityEngine;
using UnityEditor;
using System.Collections.Generic;&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot; data-start=&quot;43&quot; data-line=&quot;43-44&quot;&gt;&lt;code&gt;    private List&amp;lt;Log&amp;gt; logs;
    private Log selectedLog;&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot; data-start=&quot;53&quot; data-line=&quot;77,78&quot;&gt;&lt;code&gt;    private void OnEnable()
    {
        errorIcon = EditorGUIUtility.Load(&amp;quot;icons/console.erroricon.png&amp;quot;) as Texture2D;
        warningIcon = EditorGUIUtility.Load(&amp;quot;icons/console.warnicon.png&amp;quot;) as Texture2D;
        infoIcon = EditorGUIUtility.Load(&amp;quot;icons/console.infoicon.png&amp;quot;) as Texture2D;

        errorIconSmall = EditorGUIUtility.Load(&amp;quot;icons/console.erroricon.sml.png&amp;quot;) as Texture2D;
        warningIconSmall = EditorGUIUtility.Load(&amp;quot;icons/console.warnicon.sml.png&amp;quot;) as Texture2D;
        infoIconSmall = EditorGUIUtility.Load(&amp;quot;icons/console.infoicon.sml.png&amp;quot;) as Texture2D;

        resizerStyle = new GUIStyle();
        resizerStyle.normal.background = EditorGUIUtility.Load(&amp;quot;icons/d_AvatarBlendBackground.png&amp;quot;) as Texture2D;

        boxStyle = new GUIStyle();
        boxStyle.normal.textColor = new Color(0.9f, 0.9f, 0.9f);

        boxBgOdd = EditorGUIUtility.Load(&amp;quot;builtin skins/darkskin/images/cn entrybackodd.png&amp;quot;) as Texture2D;
        boxBgEven = EditorGUIUtility.Load(&amp;quot;builtin skins/darkskin/images/cnentrybackeven.png&amp;quot;) as Texture2D;
        boxBgSelected = EditorGUIUtility.Load(&amp;quot;builtin skins/darkskin/images/menuitemhover.png&amp;quot;) as Texture2D;

        textAreaStyle = new GUIStyle();
        textAreaStyle.normal.textColor = new Color(0.9f, 0.9f, 0.9f);
        textAreaStyle.normal.background = EditorGUIUtility.Load(&amp;quot;builtin skins/darkskin/images/projectbrowsericonareabg.png&amp;quot;) as Texture2D;
    
        logs = new List&amp;lt;Log&amp;gt;();
        selectedLog = null;
    }&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot; data-start=&quot;117&quot; data-line=&quot;124-137,150-153&quot;&gt;&lt;code&gt;    private void DrawUpperPanel()
    {
        upperPanel = new Rect(0, menuBarHeight, position.width, (position.height * sizeRatio) - menuBarHeight);

        GUILayout.BeginArea(upperPanel);
        upperPanelScroll = GUILayout.BeginScrollView(upperPanelScroll);

        for (int i = 0; i &amp;lt; logs.Count; i++)
        {
            if (DrawBox(logs[i].info, logs[i].type, i % 2 == 0, logs[i].isSelected))
            {
                if (selectedLog != null)
                {
                    selectedLog.isSelected = false;
                }

                logs[i].isSelected = true;
                selectedLog = logs[i];
                GUI.changed = true;
            }
        }

        GUILayout.EndScrollView();
        GUILayout.EndArea();
    }

    private void DrawLowerPanel()
    {
        lowerPanel = new Rect(0, (position.height * sizeRatio) + resizerHeight, position.width, (position.height * (1 - sizeRatio)) - resizerHeight);

        GUILayout.BeginArea(lowerPanel);
        lowerPanelScroll = GUILayout.BeginScrollView(lowerPanelScroll);

        if (selectedLog != null)
        {
            GUILayout.TextArea(selectedLog.message, textAreaStyle);
        }

        GUILayout.EndScrollView();
        GUILayout.EndArea();
    }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to receive logs from &lt;code class=&quot;highlighter-rouge&quot;&gt;Debug.Log()&lt;/code&gt; calls, we need to tap into Unity’s log message event. Generally, we can’t access parts of Unity API that are restricted to main thread but, fortunately, Unity exposes an application event called &lt;code class=&quot;highlighter-rouge&quot;&gt;logMessageReceived&lt;/code&gt;. We are going to subscribe to this event in &lt;code class=&quot;highlighter-rouge&quot;&gt;OnEnable()&lt;/code&gt; and in the subscriber method we will create a &lt;code class=&quot;highlighter-rouge&quot;&gt;Log&lt;/code&gt; object and add it the list of logs.&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot; data-start=&quot;53&quot; data-line=&quot;80,83-91&quot;&gt;&lt;code&gt;    private void OnEnable()
    {
        errorIcon = EditorGUIUtility.Load(&amp;quot;icons/console.erroricon.png&amp;quot;) as Texture2D;
        warningIcon = EditorGUIUtility.Load(&amp;quot;icons/console.warnicon.png&amp;quot;) as Texture2D;
        infoIcon = EditorGUIUtility.Load(&amp;quot;icons/console.infoicon.png&amp;quot;) as Texture2D;

        errorIconSmall = EditorGUIUtility.Load(&amp;quot;icons/console.erroricon.sml.png&amp;quot;) as Texture2D;
        warningIconSmall = EditorGUIUtility.Load(&amp;quot;icons/console.warnicon.sml.png&amp;quot;) as Texture2D;
        infoIconSmall = EditorGUIUtility.Load(&amp;quot;icons/console.infoicon.sml.png&amp;quot;) as Texture2D;

        resizerStyle = new GUIStyle();
        resizerStyle.normal.background = EditorGUIUtility.Load(&amp;quot;icons/d_AvatarBlendBackground.png&amp;quot;) as Texture2D;

        boxStyle = new GUIStyle();
        boxStyle.normal.textColor = new Color(0.9f, 0.9f, 0.9f);

        boxBgOdd = EditorGUIUtility.Load(&amp;quot;builtin skins/darkskin/images/cn entrybackodd.png&amp;quot;) as Texture2D;
        boxBgEven = EditorGUIUtility.Load(&amp;quot;builtin skins/darkskin/images/cnentrybackeven.png&amp;quot;) as Texture2D;
        boxBgSelected = EditorGUIUtility.Load(&amp;quot;builtin skins/darkskin/images/menuitemhover.png&amp;quot;) as Texture2D;

        textAreaStyle = new GUIStyle();
        textAreaStyle.normal.textColor = new Color(0.9f, 0.9f, 0.9f);
        textAreaStyle.normal.background = EditorGUIUtility.Load(&amp;quot;builtin skins/darkskin/images/projectbrowsericonareabg.png&amp;quot;) as Texture2D;
    
        logs = new List&amp;lt;Log&amp;gt;();
        selectedLog = null;

        Application.logMessageReceived += LogMessageReceived;
    }

    private void OnDisable()
    {
        Application.logMessageReceived -= LogMessageReceived;
    }

    private void OnDestroy()
    {
        Application.logMessageReceived -= LogMessageReceived;
    }&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot; data-start=&quot;239&quot; data-line=&quot;239-243&quot;&gt;&lt;code&gt;    private void LogMessageReceived(string condition, string stackTrace, LogType type)
    {
        Log l = new Log(false, condition, stackTrace, type);
        logs.Add(l);
    }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time for the ultimate test: take your &lt;strong&gt;ResizablePanels.cs&lt;/strong&gt; code to a working application of yours or just create a new &lt;code class=&quot;highlighter-rouge&quot;&gt;Monobehaviour&lt;/code&gt; in your current project. Throw in a couple of &lt;code class=&quot;highlighter-rouge&quot;&gt;Debug.Log()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Debug.LogWarning()&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Debug.LogError()&lt;/code&gt; calls and see how your window works.&lt;/p&gt;

&lt;div class=&quot;img-wrapper&quot;&gt;
    
        &lt;img src=&quot;/assets/img/resizable-panels-working.png&quot; class=&quot;center&quot; alt=&quot;Resizable Panels&quot; width=&quot;400px&quot; /&gt;
    
    &lt;div class=&quot;empty-caption&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;This concludes our tutorial on creating a clone of the console window. Now we have a window that looks almost exactly like a console, and has similar functionality (implementing the rest of the functionality can be an exercise for the reader :) ). Let’s review what we learned in this post:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Styling GUI elements as a menu bar.&lt;/li&gt;
  &lt;li&gt;Laying out GUI elements both vertically and horizontally.&lt;/li&gt;
  &lt;li&gt;Creating buttons and toggles.&lt;/li&gt;
  &lt;li&gt;Adding texture to GUI elements.&lt;/li&gt;
  &lt;li&gt;Creating scroll views.&lt;/li&gt;
  &lt;li&gt;Subscribing to Unity’s Debug events.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It doesn’t seem like a lot, but believe me, we have covered everything you need to know in order to build your own editor windows. In the next blog post, we will have a look at node-based editors and start creating them for ourselves. And as I promised, &lt;a href=&quot;https://github.com/oguzkonya/post--creating-unity-console-window&quot;&gt;here&lt;/a&gt; is the script in full. Until next time.&lt;/p&gt;</content><author><name>Oguz Konya</name></author><summary type="html">In our last post we created a Unity window and added two resizable panels. In this post, we will improve upon it and make it a clone of Unity’s console window. This post is going to be a little bit longer, so I will omit the previously written code, but the final version will still be available in full at the end.</summary></entry><entry><title type="html">Creating Editor Windows in Unity</title><link href="https://oguzkonya.github.io/creating-editor-windows-in-unity/" rel="alternate" type="text/html" title="Creating Editor Windows in Unity" /><published>2019-08-01T00:00:00+00:00</published><updated>2019-08-01T00:00:00+00:00</updated><id>https://oguzkonya.github.io/creating-editor-windows-in-unity</id><content type="html" xml:base="https://oguzkonya.github.io/creating-editor-windows-in-unity/">&lt;p&gt;For the last decade, Unity has been a great platform for developing games that provides a large number of tools to developers: rendering engine, physics engine, animation systems, audio mixers etc. However, when creating levels or generating in-game data, Unity falls short, because each game is unique and requires different kinds of tools. Thankfully, Unity has an API available to us developers to create our own editor windows, custom drawers and inspector panels. In this series of blog posts, I am going to show you how I develop custom editors in Unity for designers and artists. We will start by creating an editor window, put two panels in it, and then make it resizable. In the &lt;a href=&quot;/creating-clone-unitys-console-window/&quot;&gt;next&lt;/a&gt; post, we will turn that window into a clone of Unity’s own Console window.&lt;/p&gt;

&lt;h2 id=&quot;creating-an-editor-window&quot;&gt;Creating an Editor Window&lt;/h2&gt;

&lt;p&gt;Well then, let’s start! First, we are going to create an empty Unity project and add a folder named &lt;strong&gt;Editor&lt;/strong&gt; under &lt;strong&gt;Assets&lt;/strong&gt;. If you give folders in Unity certain names, it will treat their contents in a special way. &lt;strong&gt;Editor&lt;/strong&gt; is one of those names and the scripts in this folder will become a part of Unity’s own editor. So, then, let’s build an editor window script: go into the &lt;strong&gt;Editor&lt;/strong&gt; folder you just created, right-click, and select &lt;strong&gt;Create&lt;/strong&gt; &lt;strong&gt;-&amp;gt; C# Script&lt;/strong&gt;. You can also select &lt;strong&gt;Editor Test C# Script&lt;/strong&gt;, but we will change all the content anyway, so it doesn’t actually matter. Name your script &lt;code class=&quot;highlighter-rouge&quot;&gt;ResizablePanels&lt;/code&gt; and then open it in your favourite text editor (I prefer Visual Studio on Windows and Rider on Mac).&lt;/p&gt;

&lt;p&gt;Since this is going to be an editor window, the class should derive from &lt;code class=&quot;highlighter-rouge&quot;&gt;EditorWindow&lt;/code&gt; instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;MonoBehaviour&lt;/code&gt;. The &lt;code class=&quot;highlighter-rouge&quot;&gt;EditorWindow&lt;/code&gt; class resides in &lt;code class=&quot;highlighter-rouge&quot;&gt;UnityEditor&lt;/code&gt; namespace, so we will need to add it as well.&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot; data-filename=&quot;ResizablePanels.cs&quot;&gt;&lt;code&gt;using UnityEngine;
using UnityEditor;

public class ResizablePanels : EditorWindow
{

}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Editor windows require a static method to be initialized. In this method, we are going build the window and (optional) give it a title. &lt;code class=&quot;highlighter-rouge&quot;&gt;GetWindow()&lt;/code&gt; is an &lt;code class=&quot;highlighter-rouge&quot;&gt;EditorWindow&lt;/code&gt; method which creates the window, if it doesn’t exist, or finds and focuses on it if it does.&lt;/p&gt;

&lt;p&gt;However, a static method on its own will not be enough, we also need to add a button, or something like it, to let our users open the window within Unity. Thankfully there is already an attribute called &lt;code class=&quot;highlighter-rouge&quot;&gt;MenuItem&lt;/code&gt; which adds a menu item to Unity’s menu bar and runs the method it is applied to. So, the following code will create the most basic editor window you can create in Unity.&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot; data-line=&quot;6-11&quot;&gt;&lt;code&gt;using UnityEngine;
using UnityEditor;

public class ResizablePanels : EditorWindow
{
    [MenuItem(&amp;quot;Window/Resizable Panels&amp;quot;)]
    private static void OpenWindow()
    {
        ResizablePanels window = GetWindow&amp;lt;ResizablePanels&amp;gt;();
        window.titleContent = new GUIContent(&amp;quot;Resizable Panels&amp;quot;);
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is the menu item:&lt;/p&gt;

&lt;div class=&quot;img-wrapper&quot;&gt;
    
        &lt;img src=&quot;/assets/img/menu-item.png&quot; class=&quot;center&quot; alt=&quot;Menu item&quot; width=&quot;300px&quot; /&gt;
    
    &lt;div class=&quot;empty-caption&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;And here is our window that is opened when you click it:&lt;/p&gt;

&lt;div class=&quot;img-wrapper&quot;&gt;
    
        &lt;img src=&quot;/assets/img/window.png&quot; class=&quot;center&quot; alt=&quot;Window&quot; width=&quot;300px&quot; /&gt;
    
    &lt;div class=&quot;empty-caption&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;In order to draw in this window, we will use the &lt;code class=&quot;highlighter-rouge&quot;&gt;OnGUI()&lt;/code&gt; method (yes, Unity’s own editor system still uses the old GUI system and it probably won’t change for a long time). But first, we need two rectangles to define our panels. I will also draw these panels in their own methods, so while we are at it, we should add those methods, too.&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot; data-line=&quot;6,7,16-28&quot;&gt;&lt;code&gt;using UnityEngine;
using UnityEditor;

public class ResizablePanels : EditorWindow
{
    private Rect upperPanel;
    private Rect lowerPanel;

    [MenuItem(&amp;quot;Window/Resizable Panels&amp;quot;)]
    private static void OpenWindow()
    {
        ResizablePanels window = GetWindow&amp;lt;ResizablePanels&amp;gt;();
        window.titleContent = new GUIContent(&amp;quot;Resizable Panels&amp;quot;);
    }
    
    private void OnGUI()
    {
        DrawUpperPanel();
        DrawLowerPanel();
    }
    
    private void DrawUpperPanel()
    {
    }
    
    private void DrawLowerPanel()
    {
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our editor window is starting to shape up. All we need to do now is to draw the panels and check if they work correctly. &lt;code class=&quot;highlighter-rouge&quot;&gt;GUILayout.BeginArea(Rect rect)&lt;/code&gt; would create a rectangle area to draw in and &lt;code class=&quot;highlighter-rouge&quot;&gt;GUILayout.EndArea()&lt;/code&gt; marks the end. These areas will define our panels. I am also going to add a label in both areas so that we can see how they look. Let’s fill in &lt;code class=&quot;highlighter-rouge&quot;&gt;DrawUpperPanel()&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;DrawLowerPanel()&lt;/code&gt;:&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot; data-line=&quot;24-28,33-37&quot;&gt;&lt;code&gt;using UnityEngine;
using UnityEditor;

public class ResizablePanels : EditorWindow
{
    private Rect upperPanel;
    private Rect lowerPanel;

    [MenuItem(&amp;quot;Window/Resizable Panels&amp;quot;)]
    private static void OpenWindow()
    {
        ResizablePanels window = GetWindow&amp;lt;ResizablePanels&amp;gt;();
        window.titleContent = new GUIContent(&amp;quot;Resizable Panels&amp;quot;);
    }

    private void OnGUI()
    {
        DrawUpperPanel();
        DrawLowerPanel();
    }

    private void DrawUpperPanel()
    {
        upperPanel = new Rect(0, 0, position.width, position.height * 0.5f);

        GUILayout.BeginArea(upperPanel);
        GUILayout.Label(&amp;quot;Upper Panel&amp;quot;);
        GUILayout.EndArea();
    }

    private void DrawLowerPanel()
    {
        lowerPanel = new Rect(0, position.height * 0.5f, position.width, position.height * 0.5f);

        GUILayout.BeginArea(lowerPanel);
        GUILayout.Label(&amp;quot;Lower Panel&amp;quot;);
        GUILayout.EndArea();
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Well, they seem to be working:&lt;/p&gt;

&lt;div class=&quot;img-wrapper&quot;&gt;
    
        &lt;img src=&quot;/assets/img/window-2.png&quot; class=&quot;center&quot; alt=&quot;Window&quot; width=&quot;300px&quot; /&gt;
    
    &lt;div class=&quot;empty-caption&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;However, those two panels are set to cover half of the window each, but if we want them to be resizable, they need to have variable heights. So, I am going to add a size ratio variable; this way, when one panel covers a certain amount of the window, the other can cover the remaining part.&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot; data-line=&quot;9,26,35&quot;&gt;&lt;code&gt;using UnityEngine;
using UnityEditor;

public class ResizablePanels : EditorWindow
{
    private Rect upperPanel;
    private Rect lowerPanel;

    private float sizeRatio = 0.5f;

    [MenuItem(&amp;quot;Window/Resizable Panels&amp;quot;)]
    private static void OpenWindow()
    {
        ResizablePanels window = GetWindow&amp;lt;ResizablePanels&amp;gt;();
        window.titleContent = new GUIContent(&amp;quot;Resizable Panels&amp;quot;);
    }

    private void OnGUI()
    {
        DrawUpperPanel();
        DrawLowerPanel();
    }

    private void DrawUpperPanel()
    {
        upperPanel = new Rect(0, 0, position.width, position.height * sizeRatio);

        GUILayout.BeginArea(upperPanel);
        GUILayout.Label(&amp;quot;Upper Panel&amp;quot;);
        GUILayout.EndArea();
    }

    private void DrawLowerPanel()
    {
        lowerPanel = new Rect(0, (position.height * sizeRatio), position.width, position.height * (1 - sizeRatio));

        GUILayout.BeginArea(lowerPanel);
        GUILayout.Label(&amp;quot;Lower Panel&amp;quot;);
        GUILayout.EndArea();
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;resizing-panels&quot;&gt;Resizing Panels&lt;/h2&gt;

&lt;p&gt;OK, both panels have variable heights… but we still can’t resize them! But don’t worry, we are not too far from the final product. Now we just need another rectangle area, so that when the user clicks down there we can start resizing. I am going to add that area just between the two panels. It is going to be 10 pixels tall, because, well, why not? I like 10.&lt;/p&gt;

&lt;p&gt;We also need to show the user that the mouse pointer is in the resizing area. &lt;code class=&quot;highlighter-rouge&quot;&gt;EditorGUIUtility.AddCursorRect(Rect rect, MouseCursor cursor)&lt;/code&gt; does that, so we are going to use it in our drawing method.&lt;/p&gt;

&lt;p&gt;There is one more thing we need to show the user: where the resizing area begins. This is going to look like magic, but I assure you, it is not: we will use one of Unity’s own icons and stretch it and place it so that it looks like a line between upper and lower panels.&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot; data-line=&quot;11,13,22-26,32,53-61&quot;&gt;&lt;code&gt;using UnityEngine;
using UnityEditor;

public class ResizablePanels : EditorWindow
{
    private Rect upperPanel;
    private Rect lowerPanel;
    private Rect resizer;

    private float sizeRatio = 0.5f;
    private bool isResizing;

    private GUIStyle resizerStyle;

    [MenuItem(&amp;quot;Window/Resizable Panels&amp;quot;)]
    private static void OpenWindow()
    {
        ResizablePanels window = GetWindow&amp;lt;ResizablePanels&amp;gt;();
        window.titleContent = new GUIContent(&amp;quot;Resizable Panels&amp;quot;);
    }

    private void OnEnable()
    {
        resizerStyle = new GUIStyle();
        resizerStyle.normal.background = EditorGUIUtility.Load(&amp;quot;icons/d_AvatarBlendBackground.png&amp;quot;) as Texture2D;
    }

    private void OnGUI()
    {
        DrawUpperPanel();
        DrawLowerPanel();
        DrawResizer();
    }

    private void DrawUpperPanel()
    {
        upperPanel = new Rect(0, 0, position.width, position.height * sizeRatio);

        GUILayout.BeginArea(upperPanel);
        GUILayout.Label(&amp;quot;Upper Panel&amp;quot;);
        GUILayout.EndArea();
    }

    private void DrawLowerPanel()
    {
        lowerPanel = new Rect(0, (position.height * sizeRatio) + 5, position.width, position.height * (1 - sizeRatio) - 5);

        GUILayout.BeginArea(lowerPanel);
        GUILayout.Label(&amp;quot;Lower Panel&amp;quot;);
        GUILayout.EndArea();
    }

    private void DrawResizer()
    {
        resizer = new Rect(0, (position.height * sizeRatio) - 5f, position.width, 10f);

        GUILayout.BeginArea(new Rect(resizer.position + (Vector2.up * 5f), new Vector2(position.width, 2)), resizerStyle);
        GUILayout.EndArea();

        EditorGUIUtility.AddCursorRect(resizer, MouseCursor.ResizeVertical);
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Almost finished:&lt;/p&gt;

&lt;div class=&quot;img-wrapper&quot;&gt;
    
        &lt;img src=&quot;/assets/img/window-3.png&quot; class=&quot;center&quot; alt=&quot;Window&quot; width=&quot;300px&quot; /&gt;
    
    &lt;div class=&quot;empty-caption&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;And now, we will finalize it by adding the actual interaction. We will process the incoming events and if the event is a &lt;code class=&quot;highlighter-rouge&quot;&gt;mouse down&lt;/code&gt; event and it is in the resizing area, we will start resizing.&lt;/p&gt;

&lt;pre class=&quot;language-csharp  line-numbers &quot; data-line=&quot;34,36,67-93&quot;&gt;&lt;code&gt;using UnityEngine;
using UnityEditor;

public class ResizablePanels : EditorWindow
{
    private Rect upperPanel;
    private Rect lowerPanel;
    private Rect resizer;

    private float sizeRatio = 0.5f;
    private bool isResizing;

    private GUIStyle resizerStyle;

    [MenuItem(&amp;quot;Window/Resizable Panels&amp;quot;)]
    private static void OpenWindow()
    {
        ResizablePanels window = GetWindow&amp;lt;ResizablePanels&amp;gt;();
        window.titleContent = new GUIContent(&amp;quot;Resizable Panels&amp;quot;);
    }

    private void OnEnable()
    {
        resizerStyle = new GUIStyle();
        resizerStyle.normal.background = EditorGUIUtility.Load(&amp;quot;icons/d_AvatarBlendBackground.png&amp;quot;) as Texture2D;
    }

    private void OnGUI()
    {
        DrawUpperPanel();
        DrawLowerPanel();
        DrawResizer();

        ProcessEvents(Event.current);

        if (GUI.changed) Repaint();
    }

    private void DrawUpperPanel()
    {
        upperPanel = new Rect(0, 0, position.width, position.height * sizeRatio);

        GUILayout.BeginArea(upperPanel);
        GUILayout.Label(&amp;quot;Upper Panel&amp;quot;);
        GUILayout.EndArea();
    }

    private void DrawLowerPanel()
    {
        lowerPanel = new Rect(0, (position.height * sizeRatio) + 5, position.width, position.height * (1 - sizeRatio) - 5);

        GUILayout.BeginArea(lowerPanel);
        GUILayout.Label(&amp;quot;Lower Panel&amp;quot;);
        GUILayout.EndArea();
    }

    private void DrawResizer()
    {
        resizer = new Rect(0, (position.height * sizeRatio) - 5f, position.width, 10f);

        GUILayout.BeginArea(new Rect(resizer.position + (Vector2.up * 5f), new Vector2(position.width, 2)), resizerStyle);
        GUILayout.EndArea();

        EditorGUIUtility.AddCursorRect(resizer, MouseCursor.ResizeVertical);
    }

    private void ProcessEvents(Event e)
    {
        switch (e.type)
        {
            case EventType.MouseDown:
                if (e.button == 0 &amp;amp;&amp;amp; resizer.Contains(e.mousePosition))
                {
                    isResizing = true;
                }
                break;

            case EventType.MouseUp:
                isResizing = false;
                break;
        }

        Resize(e);
    }

    private void Resize(Event e)
    {
        if (isResizing)
        {
            sizeRatio = e.mousePosition.y / position.height;
            Repaint();
        }
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here is the finished version:&lt;/p&gt;

&lt;div class=&quot;img-wrapper&quot;&gt;
    
    &lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;/assets/img/resizable-panels.gif&quot;&gt;
    
        &lt;img src=&quot;/assets/img/resizable-panels.gif&quot; class=&quot;center&quot; alt=&quot;Window&quot; width=&quot;300px&quot; /&gt;
    
    &lt;/a&gt;
    
    &lt;em&gt;Click on the image to see the window in action&lt;/em&gt;
&lt;/div&gt;

&lt;p&gt;As you can see, creating an editor window in Unity with resizable panels is fairly easy. In the &lt;a href=&quot;/creating-clone-unitys-console-window/&quot;&gt;next&lt;/a&gt; blog post we will build on this editor window to create a clone of Unity’s console window.&lt;/p&gt;

&lt;p&gt;You can find the full source code &lt;a href=&quot;https://github.com/oguzkonya/post--creating-editor-windows&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;</content><author><name>Oguz Konya</name></author><summary type="html">For the last decade, Unity has been a great platform for developing games that provides a large number of tools to developers: rendering engine, physics engine, animation systems, audio mixers etc. However, when creating levels or generating in-game data, Unity falls short, because each game is unique and requires different kinds of tools. Thankfully, Unity has an API available to us developers to create our own editor windows, custom drawers and inspector panels. In this series of blog posts, I am going to show you how I develop custom editors in Unity for designers and artists. We will start by creating an editor window, put two panels in it, and then make it resizable. In the next post, we will turn that window into a clone of Unity’s own Console window.</summary></entry></feed>